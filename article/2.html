<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><title>♻️ 자바는 어떻게 Garbage Collection을 할까?</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible"content="ie=edge"><meta name="theme-color"content="#F5F5F5"><meta name="description"content="프로그램이 실행되는 내내 프로그램에서 사용하는 변수, 함수를 비롯한 각종 데이터들은 메모리에 할당되고, 해제되기를 반복한다. 이때 ‘언제, 어떤 데이터를 해제할 것인지’ 정하는 것이 중요한 문제다. C로 프로그래밍할 때는 개발자가 직접 메모리의 할당, 해제 시점을 정해준다.int *ptr = (int*)malloc(siz..."><link rel="canonical"href="https://parksb.github.io/article/2.html"><meta name="fediverse:creator"content="@parksb@silicon.moe"><meta property="og:title"content="♻️ 자바는 어떻게 Garbage Collection을 할까?: 오브젝트의 일생 "><meta property="og:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%E2%99%BB%EF%B8%8F%20%EC%9E%90%EB%B0%94%EB%8A%94%20%EC%96%B4%EB%96%BB%EA%B2%8C%20Garbage%20Collection%EC%9D%84%20%ED%95%A0%EA%B9%8C?&subtitle=%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98%20%EC%9D%BC%EC%83%9D&date=2018.04.23"><meta property="og:description"content="프로그램이 실행되는 내내 프로그램에서 사용하는 변수, 함수를 비롯한 각종 데이터들은 메모리에 할당되고, 해제되기를 반복한다. 이때 ‘언제, 어떤 데이터를 해제할 것인지’ 정하는 것이 중요한 문제다. C로 프로그래밍할 때는 개발자가 직접 메모리의 할당, 해제 시점을 정해준다.int *ptr = (int*)malloc(siz..."><meta name="twitter:title"content="♻️ 자바는 어떻게 Garbage Collection을 할까?: 오브젝트의 일생 "><meta name="twitter:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%E2%99%BB%EF%B8%8F%20%EC%9E%90%EB%B0%94%EB%8A%94%20%EC%96%B4%EB%96%BB%EA%B2%8C%20Garbage%20Collection%EC%9D%84%20%ED%95%A0%EA%B9%8C?&subtitle=%EC%98%A4%EB%B8%8C%EC%A0%9D%ED%8A%B8%EC%9D%98%20%EC%9D%BC%EC%83%9D&date=2018.04.23"><meta name="twitter:description"content="프로그램이 실행되는 내내 프로그램에서 사용하는 변수, 함수를 비롯한 각종 데이터들은 메모리에 할당되고, 해제되기를 반복한다. 이때 ‘언제, 어떤 데이터를 해제할 것인지’ 정하는 것이 중요한 문제다. C로 프로그래밍할 때는 개발자가 직접 메모리의 할당, 해제 시점을 정해준다.int *ptr = (int*)malloc(siz..."><meta name="twitter:card"content="summary_large_image"><link rel="shortcut icon"href="../assets/favicon.ico"type="image/x-icon"><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><style>@font-face { font-family: 'Pretendard'; src: url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2'), local('Pretendard') format('woff2'); font-display: swap; }
      @font-face { font-family: 'RobotoMono'; src: local('RobotoMono'), url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2') format('woff2'); font-display: swap; }
      a:hover { color: #005ccc !important; }
      #article-content-container a:hover, #article-content-container a:focus { text-decoration: underline !important; }
      #article-content-container .table-of-contents ul li:before { content: counters(item, ".") ". "; counter-increment: item; }
      #article-content-container .footnotes > .footnotes-list > .footnote-item > span { font-size: 0.9rem; }</style></head><body style="font-family: Pretendard,sans-serif; font-size: 16px; margin: 0; padding: 20px 30px 50px 30px; word-break: keep-all;"><header id="top-container"role="navigation"><nav><a class="special-anchor"href="/"style="color: #000; text-decoration: none; cursor: pointer;"><span class="t1"style="font-size: 1.5rem; font-weight: 800;">박성범</span> <span class="t2"style="font-size: 1rem; font-weight: 400;">Simon Park</span></a></nav></header><main id="main-container"style="max-width: 800px; margin-top: 30px; margin-bottom: 30px;"><article id="article-container"><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div><h1 id="article-title"style="margin: 0; padding: 0; font-size: 1.5rem; font-weight: 700;">♻️ 자바는 어떻게 Garbage Collection을 할까?</h1><h2 id="article-subtitle"style="margin: 0; padding: 0; display: inline; font-size: 1.2rem; font-weight: 400; margin-right: .4rem;">오브젝트의 일생</h2><a href="https://github.com/parksb/parksb.github.io/commits/development/_articles/20180423_how-java-collects-garbage.md"style="color: #000; text-decoration: none; cursor: pointer;"><time id="article-date"style="font-family: RobotoMono,monospace; font-size: .8rem;">2018.04.23<span class="symbol"style="font-family: Pretendard,sans-serif;">↗</span></time></a><section id="article-content-container"style="margin-top: 30px;"><details style="margin: 0; padding: 0; display: inline; margin-bottom: 10px;"><summary style="font-weight: 700; cursor: pointer;">Table of Contents</summary><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p><div class="table-of-contents"style="font-size: 15px;"><ul style="padding: 0; margin-left: 2rem; list-style-type: none; counter-reset: item; margin: 0; padding-left: 1rem;"><li style="line-height: 1.7rem;"><a href="#memory-structure"style="text-decoration: none; cursor: pointer; color: #005ccc;">Memory Structure</a></li><li style="line-height: 1.7rem;"><a href="#garbage-collection-algorithms"style="text-decoration: none; cursor: pointer; color: #005ccc;">Garbage Collection Algorithms</a><ul style="padding: 0; margin-left: 2rem; list-style-type: none; counter-reset: item; margin: 0; padding-left: 1rem;"><li style="line-height: 1.7rem;"><a href="#reference-counting"style="text-decoration: none; cursor: pointer; color: #005ccc;">Reference Counting</a></li></ul></li><li style="line-height: 1.7rem;"><a href="#tracing"style="text-decoration: none; cursor: pointer; color: #005ccc;">Tracing</a></li><li style="line-height: 1.7rem;"><a href="#generational-gc"style="text-decoration: none; cursor: pointer; color: #005ccc;">Generational GC</a></li><li style="line-height: 1.7rem;"><a href="#references"style="text-decoration: none; cursor: pointer; color: #005ccc;">References</a></li></ul></div><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p></details><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">프로그램이 실행되는 내내 프로그램에서 사용하는 변수, 함수를 비롯한 각종 데이터들은 메모리에 할당되고, 해제되기를 반복한다. 이때 ‘언제, 어떤 데이터를 해제할 것인지’ 정하는 것이 중요한 문제다. C로 프로그래밍할 때는 개발자가 직접 메모리의 할당, 해제 시점을 정해준다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">int</span><span style="color:#D73A49"> *</span><span style="color:#24292E">ptr </span><span style="color:#D73A49">=</span><span style="color:#24292E"> (</span><span style="color:#D73A49">int*</span><span style="color:#24292E">)</span><span style="color:#6F42C1">malloc</span><span style="color:#24292E">(</span><span style="color:#D73A49">sizeof</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#24292E">) </span><span style="color:#D73A49">*</span><span style="color:#005CC5"> 3</span><span style="color:#24292E">);</span><span style="color:#6A737D"> // 메모리 할당</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">for</span><span style="color:#24292E"> (</span><span style="color:#D73A49">int</span><span style="color:#24292E"> i </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">; i </span><span style="color:#D73A49">&#x3C;</span><span style="color:#005CC5"> 3</span><span style="color:#24292E">; i</span><span style="color:#D73A49">++</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#E36209">  ptr</span><span style="color:#24292E">[i] </span><span style="color:#D73A49">=</span><span style="color:#24292E"> i;</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">for</span><span style="color:#24292E"> (</span><span style="color:#D73A49">int</span><span style="color:#24292E"> i </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">; i </span><span style="color:#D73A49">&#x3C;</span><span style="color:#005CC5"> 3</span><span style="color:#24292E">; i</span><span style="color:#D73A49">++</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#6F42C1">  printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"</span><span style="color:#005CC5">%d</span><span style="color:#032F62">"</span><span style="color:#24292E">, </span><span style="color:#E36209">ptr</span><span style="color:#24292E">[i]);</span><span style="color:#6A737D"> // 012</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1">free</span><span style="color:#24292E">(ptr);</span><span style="color:#6A737D"> // 메모리 해제</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">만약 <code style="font-family: RobotoMono,monospace;">free()</code>를 통해 메모리를 해제하지 않고 계속 동적할당을 수행한다면 사용할 수 있는 메모리가 꽉 차버리고 만다. 그런데 자바 프로그래밍을 할 때는 이러한 메모리 해제 작업을 직접 하지 않는다. 아무리 많은 객체를 만들고 지워도 메모리를 해제하는 코드는 어디에도 들어가지 않는다. 메모리 관리에 신경쓰지 않고 개발을 해도 괜찮은걸까? JVM이 Garbage Collection(GC)을 지원하기 때문에 괜찮다.</p><h2 id="memory-structure"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">Memory Structure</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">GC는 더 이상 메모리를 차지하고 있지 않아도 되는 데이터들을 메모리에서 정리하는 작업이다. GC를 다루기 전에 먼저 메모리 구조를 살펴봐야 한다. 메모리는 저장하는 데이터의 종류에 따라 크게 네가지 영역으로 나뉜다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+---------------+ High address</span></span>
<span class="line"><span>|     Stack     |</span></span>
<span class="line"><span>+-------+-------+</span></span>
<span class="line"><span>|       |       |</span></span>
<span class="line"><span>|       v       |</span></span>
<span class="line"><span>|               |</span></span>
<span class="line"><span>|       ^       |</span></span>
<span class="line"><span>|       |       |</span></span>
<span class="line"><span>+-------+-------+</span></span>
<span class="line"><span>|     Heap      |</span></span>
<span class="line"><span>+---------------+</span></span>
<span class="line"><span>| Static (Data) |</span></span>
<span class="line"><span>+---------------+</span></span>
<span class="line"><span>|  Text (Code)  |</span></span>
<span class="line"><span>+---------------+ Low address</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">스택(Stack)에는 지역변수나 메서드가 저장되며, 힙(Heap) 영역에는 런타임에 동적 할당되는 데이터가 저장된다. 스태틱(Static)과 텍스트(Text) 영역은 프로그램에 상주하는 정적 변수, 바이트 코드를 저장한다. 런타임에 빈번하게 접근이 일어나는 부분은 스택과 힙이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-java"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> static</span><span style="color:#D73A49"> void</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">String</span><span style="color:#24292E">[] args) {</span></span>
<span class="line"><span style="color:#D73A49">  do</span><span style="color:#24292E">();</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> void</span><span style="color:#D73A49"> do</span><span style="color:#24292E">() {</span></span>
<span class="line"><span style="color:#24292E">  Dog jake </span><span style="color:#D73A49">=</span><span style="color:#D73A49"> new</span><span style="color:#6F42C1"> Dog</span><span style="color:#24292E">();</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>| jake    |  +--------+</span></span>
<span class="line"><span>| do()    |  | Dog1   | jake -> Dog1</span></span>
<span class="line"><span>| main()  |  |        |</span></span>
<span class="line"><span>+---------+  +--------+</span></span>
<span class="line"><span>   Stack        Heap</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">메서드와 지역 변수들은 스택에 실행 순서대로 쌓인다. 가장 먼저 <code style="font-family: RobotoMono,monospace;">main()</code>이 실행되어 스택에 들어간다. 이어서 <code style="font-family: RobotoMono,monospace;">do()</code>가 호출되어 <code style="font-family: RobotoMono,monospace;">main()</code> 위에 들어간다. 힙에는 런타임에 크기가 변하는 오브젝트들이 쌓인다. (<code style="font-family: RobotoMono,monospace;">Object</code> 클래스를 상속받는 모든 데이터가 힙에 저장된다.) 위 예시에서 <code style="font-family: RobotoMono,monospace;">do()</code> 메서드의 지역 변수 <code style="font-family: RobotoMono,monospace;">jake</code>가 힙의 오브젝트 <code style="font-family: RobotoMono,monospace;">Dog1</code>를 가리키게 된다. <code style="font-family: RobotoMono,monospace;">do()</code>의 실행이 끝나면 아래와 같이 된다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>|         |  +--------+</span></span>
<span class="line"><span>|         |  | Dog1   |  ? -> Dog1</span></span>
<span class="line"><span>| main()  |  |        |</span></span>
<span class="line"><span>+---------+  +--------+</span></span>
<span class="line"><span>   Stack        Heap</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">메모리의 스택 영역에서 <code style="font-family: RobotoMono,monospace;">do()</code>가 나가며 <code style="font-family: RobotoMono,monospace;">Dog1</code> 오브젝트를 가리키는 지역 변수 <code style="font-family: RobotoMono,monospace;">jake</code>가 사라져버렸다. 더 이상 <code style="font-family: RobotoMono,monospace;">Dog1</code> 오브젝트에 접근할 수 있는 방법이 없다. 이렇게 스택의 지역 변수로 레퍼런스가 이어지지 않는 오브젝트는 garbage가 된다. 이렇게 레퍼런스가 소멸해서 사용할 수 없어진 오브젝트를 메모리에서 제거하는 것이 바로 garbage collector가 하는 일이다.</p><h2 id="garbage-collection-algorithms"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">Garbage Collection Algorithms</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">그럼 본격적으로 GC가 작동하는 방법에 대해 알아보자. 가장 먼저 드는 생각은 단순히 메서드 실행이 끝날 때마다 GC를 수행하면 될 것 같다. 하지만 그렇게 하려면 collector가 계속 메모리를 모니터링해야 하고, 수시로 GC가 일어날 수 있기 때문에 프로그램의 성능을 크게 떨어뜨리는 문제가 있다. 그래서 몇가지 효율적인 방법이 고안되었다.</p><h3 id="reference-counting"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">Reference Counting</h3><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">레퍼런스 카운팅은 주기적으로 GC를 수행할 때 오브젝트에 몇 개의 레퍼런스가 연결되어 있는지 체크하는 방법이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-java"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> static</span><span style="color:#D73A49"> void</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">String</span><span style="color:#24292E">[] args) {</span></span>
<span class="line"><span style="color:#D73A49">  do</span><span style="color:#24292E">();</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> void</span><span style="color:#D73A49"> do</span><span style="color:#24292E">() {</span></span>
<span class="line"><span style="color:#24292E">  Dog jake </span><span style="color:#D73A49">=</span><span style="color:#D73A49"> new</span><span style="color:#6F42C1"> Dog</span><span style="color:#24292E">();</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>| jake    |  +---------+</span></span>
<span class="line"><span>| do()    |  | Dog1[1] |  jake -> Dog1</span></span>
<span class="line"><span>| main()  |  |         |</span></span>
<span class="line"><span>+---------+  +---------+</span></span>
<span class="line"><span>   Stack         Heap</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">do()</code>의 지역 변수 <code style="font-family: RobotoMono,monospace;">jake</code> 하나가 <code style="font-family: RobotoMono,monospace;">Dog1</code> 오브젝트를 가리키고 있으므로 <code style="font-family: RobotoMono,monospace;">Dog1</code>의 카운터는 1이다. 이처럼 레퍼런스가 이어지면 카운터를 하나 늘리고, 레퍼런스가 끊기면 카운터를 하나 줄여서 GC를 수행할 때 카운터가 0인 것들만 지워주면 된다. 매우 직관적이고 구현이 쉬운 방법이다. 하지만 문제가 있다. 아래와 같이 오브젝트가 서로를 가리키는 상황이 올 수 있다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-java"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> static</span><span style="color:#D73A49"> void</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">String</span><span style="color:#24292E">[] args) {</span></span>
<span class="line"><span style="color:#D73A49">  do</span><span style="color:#24292E">();</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> void</span><span style="color:#D73A49"> do</span><span style="color:#24292E">() {</span></span>
<span class="line"><span style="color:#24292E">  Dog jake </span><span style="color:#D73A49">=</span><span style="color:#D73A49"> new</span><span style="color:#6F42C1"> Dog</span><span style="color:#24292E">();</span></span>
<span class="line"><span style="color:#24292E">  Cat cake </span><span style="color:#D73A49">=</span><span style="color:#D73A49"> new</span><span style="color:#6F42C1"> Cat</span><span style="color:#24292E">();</span></span>
<span class="line"></span>
<span class="line"><span style="color:#24292E">  jake.</span><span style="color:#6F42C1">setFollowingCat</span><span style="color:#24292E">(cake);</span></span>
<span class="line"><span style="color:#24292E">  cake.</span><span style="color:#6F42C1">setFollowingDog</span><span style="color:#24292E">(jake);</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> class</span><span style="color:#6F42C1"> Dog</span><span style="color:#24292E"> {</span></span>
<span class="line"><span style="color:#D73A49">  private</span><span style="color:#24292E"> Cat followingCat;</span></span>
<span class="line"><span style="color:#D73A49">  public</span><span style="color:#D73A49"> void</span><span style="color:#6F42C1"> setFollowingCat</span><span style="color:#24292E">(Cat </span><span style="color:#E36209">c</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#005CC5">    this</span><span style="color:#24292E">.followingCat </span><span style="color:#D73A49">=</span><span style="color:#24292E"> c;</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">public</span><span style="color:#D73A49"> class</span><span style="color:#6F42C1"> Cat</span><span style="color:#24292E"> {</span></span>
<span class="line"><span style="color:#D73A49">  private</span><span style="color:#24292E"> Dog followingDog;</span></span>
<span class="line"><span style="color:#D73A49">  public</span><span style="color:#D73A49"> void</span><span style="color:#6F42C1"> setFollowingDog</span><span style="color:#24292E">(Dog </span><span style="color:#E36209">d</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#005CC5">    this</span><span style="color:#24292E">.followingDog </span><span style="color:#D73A49">=</span><span style="color:#24292E"> d;</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>| setFollowingDog() |</span></span>
<span class="line"><span>| setFollowingCat() |</span></span>
<span class="line"><span>| cake              |</span></span>
<span class="line"><span>| jake              |  +------------+  jake -> Dog1</span></span>
<span class="line"><span>| do()              |  | Dog1[2]    |  cake -> Cat1</span></span>
<span class="line"><span>| main()            |  |    Cat1[2] |  Dog1 -> cake -> Cat1</span></span>
<span class="line"><span>+-------------------+  +------------+  Cat1 -> jake -> Dog1</span></span>
<span class="line"><span>        Stack               Heap</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이렇게 <code style="font-family: RobotoMono,monospace;">Cat1</code>이 <code style="font-family: RobotoMono,monospace;">Dog1</code>을 참조하는 동시에 <code style="font-family: RobotoMono,monospace;">Dog1</code>이 <code style="font-family: RobotoMono,monospace;">Cat1</code>을 참조해 레퍼런스가 사이클링되면 <code style="font-family: RobotoMono,monospace;">do()</code>의 수행이 끝나도 <code style="font-family: RobotoMono,monospace;">Cat1</code>이 여전히 <code style="font-family: RobotoMono,monospace;">Dog1</code>을 가리키고 있기 때문에 카운터는 0이 되지 않는다. 이 문제를 해결하기 위한 방법이 있다.</p><h2 id="tracing"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">Tracing</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이름 그대로 오브젝트의 레퍼런스를 추적하는 방법이다. 처음에는 스택의 지역 변수에서 시작해 해당 변수가 가리키고 있는 오브젝트를 추적한다. 만약 오브젝트에 레퍼런스가 연결되어 있다면 해당 오브젝트의 <code style="font-family: RobotoMono,monospace;">marked</code> 값을 <code style="font-family: RobotoMono,monospace;">true</code>로 설정한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>| setFollowingDog() |</span></span>
<span class="line"><span>| setFollowingCat() |</span></span>
<span class="line"><span>| cake              |</span></span>
<span class="line"><span>| jake              |  +----------------+  jake -> Dog1</span></span>
<span class="line"><span>| do()              |  | Dog1[true]     |  cake -> Cat1</span></span>
<span class="line"><span>| main()            |  |     Cat1[true] |  Dog1 -> cake -> Cat1</span></span>
<span class="line"><span>+-------------------+  +----------------+  Cat1 -> jake -> Dog1</span></span>
<span class="line"><span>        Stack                 Heap</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">만약 지역 변수로부터의 레퍼런스가 끊기면 연결된 오브젝트들의 <code style="font-family: RobotoMono,monospace;">marked</code> 값을 <code style="font-family: RobotoMono,monospace;">false</code>로 설정한다. GC를 수행할 때는 <code style="font-family: RobotoMono,monospace;">marked</code> 값이 <code style="font-family: RobotoMono,monospace;">false</code>인 오브젝트들만 메모리에서 해제하면 된다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>|         |  +----------------+  ? -> Dog1</span></span>
<span class="line"><span>|         |  | Dog1[false]    |  ? -> Cat1</span></span>
<span class="line"><span>| main()  |  |    Cat1[false] |  Dog1 -> cake(Cat1)</span></span>
<span class="line"><span>+---------+  +----------------+  Cat1 -> jake(Dog1)</span></span>
<span class="line"><span>   Stack            Heap</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">괜찮아 보인다. 그런데 여기서 메모리를 해제할 때 한가지 신경써야 할 이슈가 있다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+---+----------+----+------+---------+</span></span>
<span class="line"><span>|   | empty    |    |      | empty   |</span></span>
<span class="line"><span>+---+----------+----+------+---------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">메모리를 해제하고 나면 중간에 빈 공간이 생기게 된다. 빈 공간이 늘어나면 새로 메모리가 할당 될 때 틈을 비집고 들어가야 하는 상황이 발생하며, 이렇게 되면 전체 메모리 공간은 충분한데 들어갈 틈이 없어서 메모리를 할당하지 못하는 문제가 생긴다. 효율적이지 않다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+---+----+------+--------------------+</span></span>
<span class="line"><span>|   |    |      | empty              |</span></span>
<span class="line"><span>+---+----+------+--------------------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">따라서 이미 할당된 메모리 공간을 한쪽으로 모아주는 compacting 작업을 해줘야 한다. 이것도 GC과정에서 수행된다. tracing은 'mark-and-sweep’이라고도 부르며, mark-and-sweep과 compacting이 순서대로 수행되기 때문에 MSC(Mark, Sweep, Compact)라고 줄여부른다.</p><h2 id="generational-gc"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">Generational GC</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">JVM은 GC를 더 효율적으로 수행하기 위해 힙 메모리 구조를 보다 세밀하게 분류한다. GC는 기본적으로 오버헤드가 매우 큰 작업이다. GC가 시작될 때마다 JVM이 stop-the-world를 발생시켜 프로그램의 스레드를 모두 멈추고 앞서 설명한 MSC를 수행한다. 따라서 GC의 주기가 잦고, 규모가 클수록 오버헤트가 커진다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">JVM은 GC의 오버헤드를 줄이기 위해 generational GC를 사용한다. 이 방식은 '대부분의 오브젝트가 생성 이후 금방 garbage가 된다’는 통계적 관찰에서 출발했다. 보통 오브젝트가 만들어진지 얼마되지 않아 레퍼런스가 사라진다. 이 관찰을 활용해 GC의 효율을 높이기 위해 JVM은 heap의 영역을 세대별로 쪼개 관리한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>                 |--------- Old ---------|</span></span>
<span class="line"><span>+------+----+----+-----------+-----------+</span></span>
<span class="line"><span>| Eden | S0 | S1 |  Tenured  | Permanent |</span></span>
<span class="line"><span>+------+----+----+-----------+-----------+</span></span>
<span class="line"><span>|----- Young ----|</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">eden, S0, S1은 생성된지 얼마되지 않은 오브젝트들이 쌓이는 공간이기 때문에 young generation이라고 부르며, 반대로 tenured와 permanent는 old generation이라고 부른다. 순서대로 살펴보자.</p><ul style="margin: 0; padding: 0; margin-bottom: 1rem; margin-left: 2rem;"><li style="line-height: 1.7rem;">Eden: 에덴동산할 때 그 에덴이다. 오브젝트가 처음 생성됐을 때 eden에 들어간다.</li><li style="line-height: 1.7rem;">Survivor 0, Survivor 1: 생성된 이후 시간이 조금 흘렀을 때 garbage가 되지 않은 오브젝트들이 eden에서 이곳으로 옮겨진다. 에덴에서 살아남은 오브젝트들이 들어간다고 해서 survivor space라고 부른다.</li><li style="line-height: 1.7rem;">Tenured: 오래 살아있을 확률이 높은 오브젝트들이 들어간다. 여기서는 거의 GC가 수행되지 않는다.</li><li style="line-height: 1.7rem;">Permanent: 프로그램이 끝날 때까지 살아있을 오브젝트들이 들어간다.</li></ul><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이렇게 힙을 나눠 각 영역에 대해서만 GC를 수행하면 성능을 더 높일 수 있다. 구체적인 수행 절차는 다음과 같다.</p><ol style="margin: 0; padding: 0; margin-bottom: 1rem; margin-left: 2rem;"><li style="line-height: 1.7rem;">오브젝트가 계속 생성되어 Eden이 어느정도 차면 Eden에서 GC를 수행한다. (MSC 과정이 진행된다.) 여기서 garbage가 아닌 오브젝트들을 S0로 옮기고, Eden을 비운다.</li><li style="line-height: 1.7rem;">Eden에서 몇 번 GC가 이뤄지면 S0에 살아남은 오브젝트가 쌓인다. 이렇게 S0가 가득차면 Eden과 S0에서 GC를 수행해 garbage가 아닌 오브젝트들을 S1으로 복사하고 eden과 S0를 비운다.</li><li style="line-height: 1.7rem;">같은 방식으로 S1이 가득차면 Eden과 S1에서 GC를 수행해 garbage가 아닌 오브젝트들을 S0로 복사하고 Eden과 S1을 비운다. 이렇게 S0와 S1을 왔다갔다 하면서 주기적으로 GC가 수행된다.</li><li style="line-height: 1.7rem;">위 과정을 반복하다보면 유난히 오래 살아남는 오브젝트들이 나올 수 있다. 만약 오브젝트의 age counter가 일정 이상이라면 tenured로 보내 S0와 S1이 가득차지 않도록 만들어준다.</li></ol><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">오브젝트가 살아남아 다음 세대로 넘어가는 것을 promotion이라고 표현한다. 또한 young generation에서 일어나는 GC를 minor GC라고 부르고, old generation에서 일어나는 GC를 major GC라고 부른다. minor GC는 자주, 빠르게 수행된다. 반대로 major GC는 가끔, 느리게 수행된다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">자동으로 수행되는 GC를 믿지 않고 <code style="font-family: RobotoMono,monospace;">System.gc()</code> 메소드를 호출해 개발자가 GC를 강제할 수도 있는데, 성능을 크게 떨어뜨리는 매우 비효율적인 방법이기 때문에 절대 사용해서는 안 된다. (심지어 위험할 수도 있다.) 꼭 명시적으로 메모리를 해제하고 싶다면 차라리 오브젝트에 <code style="font-family: RobotoMono,monospace;">null</code>을 할당해 레퍼런스를 끊는 것이 안전하다.</p><h2 id="references"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">References</h2><ul style="margin: 0; padding: 0; margin-bottom: 1rem; margin-left: 2rem;"><li style="line-height: 1.7rem;"><a href="https://docs.oracle.com/en/java/javase/15/gctuning/introduction-garbage-collection-tuning.html#GUID-326EB4CF-8C8C-4267-8355-21AB04F0D304"style="text-decoration: none; cursor: pointer; color: #005ccc;">Oracle Help Center, “HotSpot Virtual Machine Garbage Collection Tuning Guide”</a>.</li></ul></section><section id="article-navigation"style="margin-top: 50px; overflow: hidden;"><div class="article-navigation-item article-navigation-next"style="margin-bottom: 1rem; text-align: left; float: left; margin-right: 5px;"><a href="3.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-next symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: left; float: left; margin-right: 5px;">←</div><div class="article-navigation-content article-navigation-next"style="text-align: left; float: left; margin-right: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">프로세스간 통신을 활용해 프로그래밍하기</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">학적 관리 프로그램 만들기</p></div></a></div><div class="article-navigation-item article-navigation-prev"style="margin-bottom: 1rem; text-align: right; float: right; margin-left: 5px;"><a href="1.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-prev symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: right; float: right; margin-left: 5px;">→</div><div class="article-navigation-content article-navigation-prev"style="text-align: right; float: right; margin-left: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">ES6와 함께 JavaScript로 OOP하기</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">자바스크립트의 OOP는 진정한 OOP가 아닌가?</p></div></a></div></section><section id="article-comments"><script async src="https://utteranc.es/client.js"repo="parksb/parksb.github.io-comments"issue-term="pathname"theme="github-light"crossorigin="anonymous"></script></section><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div></article></main><footer style="font-size: .8rem; color: #767676;">이 글은 CC BY-NC 4.0 라이선스에 따라 이용할 수 있습니다.</footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-LKTJ5YFJR2"></script><script>window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-LKTJ5YFJR2');</script></body></html>