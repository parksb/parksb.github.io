<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><title>하나의 타입에 강아지와 고양이 담기</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible"content="ie=edge"><meta name="theme-color"content="#F5F5F5"><meta name="description"content="여기 강아지와 고양이가 있다.data class Dog(val name: String)data class Cat(val name: String)identity 함수는 항상 파라미터를 그대로 반환하는 항등 함수다. identity(dog: Dog) 함수는 Dog 타입 인자를 받아 반환하며, identity(cat: Cat)..."><link rel="canonical"href="https://parksb.github.io/article/30.html"><meta name="fediverse:creator"content="@parksb@silicon.moe"><meta property="og:title"content="하나의 타입에 강아지와 고양이 담기: 파라미터의 다형성과 제네릭 "><meta property="og:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%ED%95%98%EB%82%98%EC%9D%98%20%ED%83%80%EC%9E%85%EC%97%90%20%EA%B0%95%EC%95%84%EC%A7%80%EC%99%80%20%EA%B3%A0%EC%96%91%EC%9D%B4%20%EB%8B%B4%EA%B8%B0&subtitle=%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98%20%EB%8B%A4%ED%98%95%EC%84%B1%EA%B3%BC%20%EC%A0%9C%EB%84%A4%EB%A6%AD&date=2019.5.12"><meta property="og:description"content="여기 강아지와 고양이가 있다.data class Dog(val name: String)data class Cat(val name: String)identity 함수는 항상 파라미터를 그대로 반환하는 항등 함수다. identity(dog: Dog) 함수는 Dog 타입 인자를 받아 반환하며, identity(cat: Cat)..."><meta name="twitter:title"content="하나의 타입에 강아지와 고양이 담기: 파라미터의 다형성과 제네릭 "><meta name="twitter:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%ED%95%98%EB%82%98%EC%9D%98%20%ED%83%80%EC%9E%85%EC%97%90%20%EA%B0%95%EC%95%84%EC%A7%80%EC%99%80%20%EA%B3%A0%EC%96%91%EC%9D%B4%20%EB%8B%B4%EA%B8%B0&subtitle=%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98%20%EB%8B%A4%ED%98%95%EC%84%B1%EA%B3%BC%20%EC%A0%9C%EB%84%A4%EB%A6%AD&date=2019.5.12"><meta name="twitter:description"content="여기 강아지와 고양이가 있다.data class Dog(val name: String)data class Cat(val name: String)identity 함수는 항상 파라미터를 그대로 반환하는 항등 함수다. identity(dog: Dog) 함수는 Dog 타입 인자를 받아 반환하며, identity(cat: Cat)..."><meta name="twitter:card"content="summary_large_image"><link rel="shortcut icon"href="../assets/favicon.ico"type="image/x-icon"><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><style>@font-face { font-family: 'Pretendard'; src: url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2'), local('Pretendard') format('woff2'); font-display: swap; }
      @font-face { font-family: 'RobotoMono'; src: local('RobotoMono'), url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2') format('woff2'); font-display: swap; }
      a:hover { color: #005ccc !important; }
      #article-content-container a:hover, #article-content-container a:focus { text-decoration: underline !important; }
      #article-content-container .table-of-contents ul li:before { content: counters(item, ".") ". "; counter-increment: item; }
      #article-content-container .footnotes > .footnotes-list > .footnote-item > span { font-size: 0.9rem; }</style></head><body style="font-family: Pretendard,sans-serif; font-size: 16px; margin: 0; padding: 20px 30px 50px 30px; word-break: keep-all;"><header id="top-container"role="navigation"><nav><a class="special-anchor"href="/"style="color: #000; text-decoration: none; cursor: pointer;"><span class="t1"style="font-size: 1.5rem; font-weight: 800;">박성범</span> <span class="t2"style="font-size: 1rem; font-weight: 400;">Simon Park</span></a></nav></header><main id="main-container"style="max-width: 800px; margin-top: 30px; margin-bottom: 30px;"><article id="article-container"><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div><h1 id="article-title"style="margin: 0; padding: 0; font-size: 1.5rem; font-weight: 700;">하나의 타입에 강아지와 고양이 담기</h1><h2 id="article-subtitle"style="margin: 0; padding: 0; display: inline; font-size: 1.2rem; font-weight: 400; margin-right: .4rem;">파라미터의 다형성과 제네릭</h2><a href="https://github.com/parksb/parksb.github.io/commits/development/_articles/20190512_ts-generic-and-wrapper-type.md"style="color: #000; text-decoration: none; cursor: pointer;"><time id="article-date"style="font-family: RobotoMono,monospace; font-size: .8rem;">2019.5.12<span class="symbol"style="font-family: Pretendard,sans-serif;">↗</span></time></a><section id="article-content-container"style="margin-top: 30px;"><details style="margin: 0; padding: 0; display: inline; margin-bottom: 10px;"><summary style="font-weight: 700; cursor: pointer;">Table of Contents</summary><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p><div class="table-of-contents"style="font-size: 15px;"><ul style="padding: 0; margin-left: 2rem; list-style-type: none; counter-reset: item; margin: 0; padding-left: 1rem;"><li style="line-height: 1.7rem;"><a href="#%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1"style="text-decoration: none; cursor: pointer; color: #005ccc;">파라미터의 다형성</a></li><li style="line-height: 1.7rem;"><a href="#%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%84%B1%EB%8A%A5-%EC%A0%80%ED%95%98"style="text-decoration: none; cursor: pointer; color: #005ccc;">제네릭으로 인한 성능 저하</a></li><li style="line-height: 1.7rem;"><a href="#references"style="text-decoration: none; cursor: pointer; color: #005ccc;">References</a></li></ul></div><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p></details><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">여기 강아지와 고양이가 있다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">data</span><span style="color:#D73A49"> class</span><span style="color:#6F42C1"> Dog</span><span style="color:#24292E">(</span><span style="color:#D73A49">val</span><span style="color:#24292E"> name: </span><span style="color:#6F42C1">String</span><span style="color:#24292E">)</span></span>
<span class="line"><span style="color:#D73A49">data</span><span style="color:#D73A49"> class</span><span style="color:#6F42C1"> Cat</span><span style="color:#24292E">(</span><span style="color:#D73A49">val</span><span style="color:#24292E"> name: </span><span style="color:#6F42C1">String</span><span style="color:#24292E">)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">identity</code> 함수는 항상 파라미터를 그대로 반환하는 항등 함수다. <code style="font-family: RobotoMono,monospace;">identity(dog: Dog)</code> 함수는 <code style="font-family: RobotoMono,monospace;">Dog</code> 타입 인자를 받아 반환하며, <code style="font-family: RobotoMono,monospace;">identity(cat: Cat)</code> 함수는 <code style="font-family: RobotoMono,monospace;">Cat</code> 타입 인자를 받아 반환한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">fun</span><span style="color:#6F42C1"> identity</span><span style="color:#24292E">(dog: </span><span style="color:#6F42C1">Dog</span><span style="color:#24292E">) </span><span style="color:#D73A49">=</span><span style="color:#24292E"> dog</span></span>
<span class="line"><span style="color:#D73A49">fun</span><span style="color:#6F42C1"> identity</span><span style="color:#24292E">(cat: </span><span style="color:#6F42C1">Cat</span><span style="color:#24292E">) </span><span style="color:#D73A49">=</span><span style="color:#24292E"> cat</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">val</span><span style="color:#24292E"> dog </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Dog</span><span style="color:#24292E">(</span><span style="color:#032F62">"Jake"</span><span style="color:#24292E">)</span></span>
<span class="line"><span style="color:#6F42C1">identity</span><span style="color:#24292E">(dog) </span><span style="color:#6A737D">// Dog("Jake")</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">val</span><span style="color:#24292E"> cat </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Cat</span><span style="color:#24292E">(</span><span style="color:#032F62">"Cake"</span><span style="color:#24292E">)</span></span>
<span class="line"><span style="color:#6F42C1">identity</span><span style="color:#24292E">(cat) </span><span style="color:#6A737D">// Cat("Cake")</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">만약 <code style="font-family: RobotoMono,monospace;">Fox</code> 타입에 대한 항등 함수를 사용하려 한다면 타입 에러가 발생할 것이다. <code style="font-family: RobotoMono,monospace;">Fox</code> 타입을 인자로 받는 <code style="font-family: RobotoMono,monospace;">identity</code> 함수를 정의하지 않았기 때문이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">data</span><span style="color:#D73A49"> class</span><span style="color:#6F42C1"> Fox</span><span style="color:#24292E">(</span><span style="color:#D73A49">val</span><span style="color:#24292E"> name: </span><span style="color:#6F42C1">String</span><span style="color:#24292E">)</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">val</span><span style="color:#24292E"> fox </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Fox</span><span style="color:#24292E">(</span><span style="color:#032F62">"Nick"</span><span style="color:#24292E">)</span></span>
<span class="line"><span style="color:#6F42C1">identity</span><span style="color:#24292E">(fox) </span><span style="color:#6A737D">// None of the following functions can be called with the arguments supplied:</span></span>
<span class="line"><span style="color:#6A737D">              // public fun identity(cat: Cat): Cat defined in root package in file File.kt</span></span>
<span class="line"><span style="color:#6A737D">              // public fun identity(dog: Dog): Dog defined in root package in file File.kt</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">새로운 타입이 추가될 때마다 인자의 타입만 다르고 똑같은 동작을 하는 <code style="font-family: RobotoMono,monospace;">identity</code> 함수를 만드는 것은 효율적이지 않다. 이때 다형성(Polymorphism)으로 문제를 해결할 수 있다.</p><h2 id="%ED%8C%8C%EB%9D%BC%EB%AF%B8%ED%84%B0%EC%9D%98-%EB%8B%A4%ED%98%95%EC%84%B1"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">파라미터의 다형성</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">다형성은 하나의 엔티티를 여러 타입으로 사용할 수 있게 해준다. 다형성에는 다양한 종류가 있지만, 여기서는 파라미터의 다형성(Parametric polymorphism)에 대해서만 다룬다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">파라미터의 다형성은 표현식을 값이 아닌 타입으로 파라미터화(Parameterization)시킨다. 파라미터화는 함수가 파라미터를 이용해 표현식을 추상화하는 것을 말한다. 가령 <code style="font-family: RobotoMono,monospace;">fun twice(x: Int) = x + x</code> 함수는 <code style="font-family: RobotoMono,monospace;">x + x</code>라는 표현식을 파라미터 <code style="font-family: RobotoMono,monospace;">x</code>로 파라미터화한 것이다. 이때 <code style="font-family: RobotoMono,monospace;">42 + 42</code>는 <code style="font-family: RobotoMono,monospace;">twice(42)</code>로 추상화된다. 함수는 파라미터를 실제 값으로 대체한다. <code style="font-family: RobotoMono,monospace;">twice</code> 함수는 파라미터 <code style="font-family: RobotoMono,monospace;">x</code>를 <code style="font-family: RobotoMono,monospace;">42</code>라는 실제 값으로 파라미터화했다. 한편 타입으로 파라미터화를 하면 타입 파라미터를 실제 타입으로 대체하게 된다. 이를 함수와 구분하기 위해 타입 추상화(Type abstraction)라는 용어를 사용한다.<sup class="footnote-ref"style="font-size: 11px; line-height: 0;"><a href="#fn1"id="fnref1"style="text-decoration: none; cursor: pointer; color: #005ccc;">[1]</a></sup></p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">앞서 본 항등 함수를 타입 파라미터 <code style="font-family: RobotoMono,monospace;">T</code>를 이용하여 타입으로 파라미터화하면 아래와 같이 작성할 수 있다. 객체 지향 프로그래밍에서는 이런 식의 파라미터의 다형성을 제네릭(Generic)이라고 부른다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">fun</span><span style="color:#24292E"> &#x3C;</span><span style="color:#6F42C1">T</span><span style="color:#24292E">> </span><span style="color:#6F42C1">identity</span><span style="color:#24292E">(x: </span><span style="color:#6F42C1">T</span><span style="color:#24292E">) </span><span style="color:#D73A49">=</span><span style="color:#24292E"> x</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">타입 파라미터 <code style="font-family: RobotoMono,monospace;">T</code>는 함수를 사용하는 시점에 실제 타입이 특정되며, <code style="font-family: RobotoMono,monospace;">Dog</code>, <code style="font-family: RobotoMono,monospace;">Cat</code>, <code style="font-family: RobotoMono,monospace;">Fox</code> 뿐 아니라 <code style="font-family: RobotoMono,monospace;">Int</code>, <code style="font-family: RobotoMono,monospace;">String</code> 등 어떤 타입이든 적용할 수 있다. 더 이상 타입별로 <code style="font-family: RobotoMono,monospace;">identity</code> 함수를 만들 필요가 없는 것이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">val</span><span style="color:#24292E"> dog </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Dog</span><span style="color:#24292E">(</span><span style="color:#032F62">"Jake"</span><span style="color:#24292E">)</span></span>
<span class="line"><span style="color:#6F42C1">identity</span><span style="color:#24292E">(dog) </span><span style="color:#6A737D">// Dog("Jake")</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">val</span><span style="color:#24292E"> fox </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Fox</span><span style="color:#24292E">(</span><span style="color:#032F62">"Nick"</span><span style="color:#24292E">)</span></span>
<span class="line"><span style="color:#6F42C1">identity</span><span style="color:#24292E">(fox) </span><span style="color:#6A737D">// Fox("Nick")</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">val</span><span style="color:#24292E"> num </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 10</span></span>
<span class="line"><span style="color:#6F42C1">identity</span><span style="color:#24292E">(</span><span style="color:#005CC5">10</span><span style="color:#24292E">) </span><span style="color:#6A737D">// 10</span></span></code></pre><h2 id="%EC%A0%9C%EB%84%A4%EB%A6%AD%EC%9C%BC%EB%A1%9C-%EC%9D%B8%ED%95%9C-%EC%84%B1%EB%8A%A5-%EC%A0%80%ED%95%98"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">제네릭으로 인한 성능 저하</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">타입 파라미터를 사용할 때마다 타입 캐스팅이 발생한다면 런타임 성능을 우려할 수도 있다. JVM은 타입 소거(Type erasure)를 통해 런타임에 타입 정보를 제거함으로써 제네릭을 구현한다. 모든 타입 파라미터는 <code style="font-family: RobotoMono,monospace;">Object</code>로 취급되며, 타입 파라미터 <code style="font-family: RobotoMono,monospace;">T</code>의 구체적인 타입을 런타임에 알 수 없다. 이렇게 JVM은 제네릭이 없던 시절에 작성된 코드에 대한 하위호환성을 보장하는 동시에 제네릭의 런타임 오버헤드를 해소한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">fun</span><span style="color:#24292E"> &#x3C;</span><span style="color:#6F42C1">T</span><span style="color:#24292E">> </span><span style="color:#6F42C1">Any</span><span style="color:#24292E">.</span><span style="color:#6F42C1">isT</span><span style="color:#24292E">() </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> this</span><span style="color:#D73A49"> is</span><span style="color:#24292E"> T </span><span style="color:#6A737D">// Cannot check for instance of erased type: T</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">인라인 함수의 경우 컴파일 타임에 함수의 내용이 사용처에 인라이닝되기 때문에 이러한 문제를 피할 수 있다. 코틀린은 인라인 함수를 사용할 때 런타임에 타입 파라미터의 구체적인 타입을 명시하는 <code style="font-family: RobotoMono,monospace;">reified</code> 키워드를 지원한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-kotlin"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">inline</span><span style="color:#D73A49"> fun</span><span style="color:#24292E"> &#x3C;</span><span style="color:#6F42C1">reified</span><span style="color:#6F42C1"> T</span><span style="color:#24292E">> </span><span style="color:#6F42C1">Any</span><span style="color:#24292E">.</span><span style="color:#6F42C1">isT</span><span style="color:#24292E">() </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> this</span><span style="color:#D73A49"> is</span><span style="color:#24292E"> T</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">러스트의 경우 단형성화(Monomorphization)을 통해 제네릭의 런타임 오버헤드를 해소한다. 단형성화는 컴파일 타임에 제네릭 코드의 사용처를 바탕으로 구체적인 타입을 가진 코드를 생성하고, 이를 사용하도록 변경하는 과정을 말한다. 가령 아래와 같은 제네릭 구조체 <code style="font-family: RobotoMono,monospace;">Point&lt;T&gt;</code>의 타입 파라미터에 <code style="font-family: RobotoMono,monospace;">i32</code>, <code style="font-family: RobotoMono,monospace;">f64</code> 타입을 전달해 사용한다고 가정하자.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-rust"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">struct</span><span style="color:#6F42C1"> Point</span><span style="color:#24292E">&#x3C;</span><span style="color:#6F42C1">T</span><span style="color:#24292E">> {</span></span>
<span class="line"><span style="color:#24292E">    x</span><span style="color:#D73A49">:</span><span style="color:#6F42C1"> T</span><span style="color:#24292E">,</span></span>
<span class="line"><span style="color:#24292E">    y</span><span style="color:#D73A49">:</span><span style="color:#6F42C1"> T</span><span style="color:#24292E">,</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">fn</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">() {</span></span>
<span class="line"><span style="color:#D73A49">    let</span><span style="color:#24292E"> integer </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Point</span><span style="color:#24292E"> { x</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 5</span><span style="color:#24292E">, y</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 10</span><span style="color:#24292E"> };</span></span>
<span class="line"><span style="color:#D73A49">    let</span><span style="color:#24292E"> float </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Point</span><span style="color:#24292E"> { x</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 1.0</span><span style="color:#24292E">, y</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 4.0</span><span style="color:#24292E"> };</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">컴파일러가 단형성화를 수행하면 아래와 같이 구체적인 타입을 명시한 구조체를 만들어 사용하게 된다. 이로써 러스트에서는 제네릭으로 인한 런타임 성능 저하가 발생하지 않는다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-rust"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">struct</span><span style="color:#6F42C1"> Point_i32</span><span style="color:#24292E"> {</span></span>
<span class="line"><span style="color:#24292E">    x</span><span style="color:#D73A49">:</span><span style="color:#6F42C1"> i32</span><span style="color:#24292E">,</span></span>
<span class="line"><span style="color:#24292E">    y</span><span style="color:#D73A49">:</span><span style="color:#6F42C1"> i32</span><span style="color:#24292E">,</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">struct</span><span style="color:#6F42C1"> Point_f64</span><span style="color:#24292E"> {</span></span>
<span class="line"><span style="color:#24292E">    x</span><span style="color:#D73A49">:</span><span style="color:#6F42C1"> f64</span><span style="color:#24292E">,</span></span>
<span class="line"><span style="color:#24292E">    y</span><span style="color:#D73A49">:</span><span style="color:#6F42C1"> f64</span><span style="color:#24292E">,</span></span>
<span class="line"><span style="color:#24292E">}</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">fn</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">() {</span></span>
<span class="line"><span style="color:#D73A49">    let</span><span style="color:#24292E"> integer </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Point_i32</span><span style="color:#24292E"> { x</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 5</span><span style="color:#24292E">, y</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 10</span><span style="color:#24292E"> };</span></span>
<span class="line"><span style="color:#D73A49">    let</span><span style="color:#24292E"> float </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> Point_f64</span><span style="color:#24292E"> { x</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 1.0</span><span style="color:#24292E">, y</span><span style="color:#D73A49">:</span><span style="color:#005CC5"> 4.0</span><span style="color:#24292E"> };</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><h2 id="references"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">References</h2><ul style="margin: 0; padding: 0; margin-bottom: 1rem; margin-left: 2rem;"><li style="line-height: 1.7rem;">조재용, 우명인, “코틀린으로 배우는 함수형 프로그래밍”, 인사이트, 2019.</li><li style="line-height: 1.7rem;"><a href="https://hjaem.info/itpl"style="text-decoration: none; cursor: pointer; color: #005ccc;">Jaemin Hong, Sukyoung Ryu, “Introduction to Programming Languages”, 2021.</a></li></ul><hr class="footnotes-sep"style="margin-top: 30px; margin-bottom: 30px; border-top: 0; border-bottom: 1px #000 solid;"><section class="footnotes"style="margin-bottom: 15px; margin-left: -1rem;"><ol class="footnotes-list"style="margin: 0; margin-left: 2rem; padding: 0; counter-reset: list;"><li id="fn1"class="footnote-item"style="list-style-position: inherit; list-style: none; line-height: 0;"><span style="counter-increment: list;">[1]</span><p style="margin-bottom: 1rem; font-size: .9rem; margin-left: .3rem; line-height: 1.4rem; display: inline;">Jaemin Hong, Sukyoung Ryu, “Introduction to Programming Languages”, 2021, pp. 21. <a href="#fnref1"class="footnote-backref"style="text-decoration: none; cursor: pointer; color: #005ccc; font-family: Pretendard,sans-serif;">↩︎</a></p></li></ol></section></section><section id="article-navigation"style="margin-top: 50px; overflow: hidden;"><div class="article-navigation-item article-navigation-next"style="margin-bottom: 1rem; text-align: left; float: left; margin-right: 5px;"><a href="31.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-next symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: left; float: left; margin-right: 5px;">←</div><div class="article-navigation-content article-navigation-next"style="text-align: left; float: left; margin-right: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">👻 CPU 보안 취약점을 공격하는 아주 구체적인 원리</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">멜트다운, 스펙터 페이퍼 읽기</p></div></a></div><div class="article-navigation-item article-navigation-prev"style="margin-bottom: 1rem; text-align: right; float: right; margin-left: 5px;"><a href="29.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-prev symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: right; float: right; margin-left: 5px;">→</div><div class="article-navigation-content article-navigation-prev"style="text-align: right; float: right; margin-left: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">💵 캐시가 동작하는 아주 구체적인 원리</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">하드웨어로 구현한 해시 테이블</p></div></a></div></section><section id="article-comments"><script async src="https://utteranc.es/client.js"repo="parksb/parksb.github.io-comments"issue-term="pathname"theme="github-light"crossorigin="anonymous"></script></section><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div></article></main><footer style="font-size: .8rem; color: #767676;">이 글은 CC BY-NC 4.0 라이선스에 따라 이용할 수 있습니다.</footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-LKTJ5YFJR2"></script><script>window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-LKTJ5YFJR2');</script></body></html>