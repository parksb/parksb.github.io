<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><title>프로세스간 통신을 활용해 프로그래밍하기</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible"content="ie=edge"><meta name="theme-color"content="#F5F5F5"><meta name="description"content="컴퓨터는 여러 개의 프로세스를 동시에 돌릴 수 있다. (사실 정확히 '동시에’는 아니다. 자세한 설명은 공룡책으로 정리하는 운영체제 Ch.1를 참고.) 그렇다면 하나의 프로그램이 여러 개의 프로세스로 메모리에 로드될 수 있을까? 당연히 된다. 두 개의 프로세스를 동시에 실행시며 하나의 목적을 달성할 수 있다. 리눅스 환경..."><link rel="canonical"href="https://parksb.github.io/article/3.html"><meta name="fediverse:creator"content="@parksb@silicon.moe"><meta property="og:title"content="프로세스간 통신을 활용해 프로그래밍하기: 학적 관리 프로그램 만들기 "><meta property="og:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84%20%ED%86%B5%EC%8B%A0%EC%9D%84%20%ED%99%9C%EC%9A%A9%ED%95%B4%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%ED%95%98%EA%B8%B0&subtitle=%ED%95%99%EC%A0%81%20%EA%B4%80%EB%A6%AC%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%20%EB%A7%8C%EB%93%A4%EA%B8%B0&date=2018.05.01"><meta property="og:description"content="컴퓨터는 여러 개의 프로세스를 동시에 돌릴 수 있다. (사실 정확히 '동시에’는 아니다. 자세한 설명은 공룡책으로 정리하는 운영체제 Ch.1를 참고.) 그렇다면 하나의 프로그램이 여러 개의 프로세스로 메모리에 로드될 수 있을까? 당연히 된다. 두 개의 프로세스를 동시에 실행시며 하나의 목적을 달성할 수 있다. 리눅스 환경..."><meta name="twitter:title"content="프로세스간 통신을 활용해 프로그래밍하기: 학적 관리 프로그램 만들기 "><meta name="twitter:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4%EA%B0%84%20%ED%86%B5%EC%8B%A0%EC%9D%84%20%ED%99%9C%EC%9A%A9%ED%95%B4%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%ED%95%98%EA%B8%B0&subtitle=%ED%95%99%EC%A0%81%20%EA%B4%80%EB%A6%AC%20%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8%20%EB%A7%8C%EB%93%A4%EA%B8%B0&date=2018.05.01"><meta name="twitter:description"content="컴퓨터는 여러 개의 프로세스를 동시에 돌릴 수 있다. (사실 정확히 '동시에’는 아니다. 자세한 설명은 공룡책으로 정리하는 운영체제 Ch.1를 참고.) 그렇다면 하나의 프로그램이 여러 개의 프로세스로 메모리에 로드될 수 있을까? 당연히 된다. 두 개의 프로세스를 동시에 실행시며 하나의 목적을 달성할 수 있다. 리눅스 환경..."><meta name="twitter:card"content="summary_large_image"><link rel="shortcut icon"href="../assets/favicon.ico"type="image/x-icon"><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><style>@font-face { font-family: 'Pretendard'; src: url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2'), local('Pretendard') format('woff2'); font-display: swap; }
      @font-face { font-family: 'RobotoMono'; src: local('RobotoMono'), url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2') format('woff2'); font-display: swap; }
      a:hover { color: #005ccc !important; }
      #article-content-container a:hover, #article-content-container a:focus { text-decoration: underline !important; }
      #article-content-container .table-of-contents ul li:before { content: counters(item, ".") ". "; counter-increment: item; }
      #article-content-container .footnotes > .footnotes-list > .footnote-item > span { font-size: 0.9rem; }</style></head><body style="font-family: Pretendard,sans-serif; font-size: 16px; margin: 0; padding: 20px 30px 50px 30px; word-break: keep-all;"><header id="top-container"role="navigation"><nav><a class="special-anchor"href="/"style="color: #000; text-decoration: none; cursor: pointer;"><span class="t1"style="font-size: 1.5rem; font-weight: 800;">박성범</span> <span class="t2"style="font-size: 1rem; font-weight: 400;">Simon Park</span></a></nav></header><main id="main-container"style="max-width: 800px; margin-top: 30px; margin-bottom: 30px;"><article id="article-container"><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div><h1 id="article-title"style="margin: 0; padding: 0; font-size: 1.5rem; font-weight: 700;">프로세스간 통신을 활용해 프로그래밍하기</h1><h2 id="article-subtitle"style="margin: 0; padding: 0; display: inline; font-size: 1.2rem; font-weight: 400; margin-right: .4rem;">학적 관리 프로그램 만들기</h2><a href="https://github.com/parksb/parksb.github.io/commits/development/_articles/20180501_management-program-with-ipc.md"style="color: #000; text-decoration: none; cursor: pointer;"><time id="article-date"style="font-family: RobotoMono,monospace; font-size: .8rem;">2018.05.01<span class="symbol"style="font-family: Pretendard,sans-serif;">↗</span></time></a><section id="article-content-container"style="margin-top: 30px;"><details style="margin: 0; padding: 0; display: inline; margin-bottom: 10px;"><summary style="font-weight: 700; cursor: pointer;">Table of Contents</summary><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p><div class="table-of-contents"style="font-size: 15px;"><ul style="padding: 0; margin-left: 2rem; list-style-type: none; counter-reset: item; margin: 0; padding-left: 1rem;"><li style="line-height: 1.7rem;"><a href="#%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EA%B5%AC%EC%A1%B0"style="text-decoration: none; cursor: pointer; color: #005ccc;">프로그램 구조</a></li><li style="line-height: 1.7rem;"><a href="#child-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1"style="text-decoration: none; cursor: pointer; color: #005ccc;">Child 프로세스 생성</a></li><li style="line-height: 1.7rem;"><a href="#%ED%8C%8C%EC%9D%B4%ED%94%84-%ED%86%B5%EC%8B%A0-%EA%B5%AC%ED%98%84"style="text-decoration: none; cursor: pointer; color: #005ccc;">파이프 통신 구현</a></li></ul></div><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p></details><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">컴퓨터는 여러 개의 프로세스를 동시에 돌릴 수 있다. (사실 정확히 '동시에’는 아니다. 자세한 설명은 <a href="https://parksb.github.io/article/5.html"style="text-decoration: none; cursor: pointer; color: #005ccc;">공룡책으로 정리하는 운영체제 Ch.1</a>를 참고.) 그렇다면 하나의 프로그램이 여러 개의 프로세스로 메모리에 로드될 수 있을까? 당연히 된다. 두 개의 프로세스를 동시에 실행시며 하나의 목적을 달성할 수 있다. 리눅스 환경에서 parent 프로세스와 child 프로세스가 통신하는 학생 정보 관리 프로그램을 만들어보았다.</p><h2 id="%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%A8-%EA%B5%AC%EC%A1%B0"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">프로그램 구조</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><img src="/images/43831555-7d8fb438-9b3f-11e8-96e0-ccfd782d089d.webp"alt decoding="async"width="800"height="121"style="max-width: 100%; height: auto; margin-bottom: -7px;"></p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">프로그램은 parent와 child로 나뉜다. parent는 클라이언트로서 사용자에게 메뉴를 출력해주고, 값을 입력받는다. child는 서버로서 parent에게 데이터를 전송받아 student.data 파일에 데이터를 쓰거나 읽는다. 전체 실행 흐름을 도식화하면 다음 플로우 차트와 같다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><img src="/images/43831554-7d0c6466-9b3f-11e8-8da3-a5c293503a5a.webp"alt loading="lazy"decoding="async"width="800"height="423"style="max-width: 100%; height: auto; margin-bottom: -7px;"></p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">서버와 클라이언트는 파이프(Pipe)를 통해 데이터를 주고 받는다. 파이프가 무엇인가? 말 그대로 parent와 child 사이에 관을 설치해 데이터를 주고받는 프로세스간 통신 기법을 말한다. <a href="https://parksb.github.io/article/7.html"style="text-decoration: none; cursor: pointer; color: #005ccc;">공룡책으로 정리하는 운영체제 Ch.3</a>에 파이프에 대한 설명이 있다.</p><h2 id="child-%ED%94%84%EB%A1%9C%EC%84%B8%EC%8A%A4-%EC%83%9D%EC%84%B1"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">Child 프로세스 생성</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">처음 프로그램이 실행됐을 때 <code style="font-family: RobotoMono,monospace;">fork()</code> 시스템콜을 통해 child 프로세스를 만들어야 한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;stdio.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;unistd.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;sys/wait.h></span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> argc</span><span style="color:#24292E">, </span><span style="color:#D73A49">char*</span><span style="color:#E36209"> argv</span><span style="color:#D73A49">[]</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">  pid_t</span><span style="color:#24292E"> pid </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> fork</span><span style="color:#24292E">();</span><span style="color:#6A737D"> // child를 생성한다.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">  if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">&#x3C;</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // 에러</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[CLIENT] Fork failed.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#D73A49"> if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">==</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // Child (Server)</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[SERVER] Child created.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#24292E"> {</span><span style="color:#6A737D"> // Parent (Client)</span></span>
<span class="line"><span style="color:#6F42C1">    wait</span><span style="color:#24292E">(</span><span style="color:#005CC5">NULL</span><span style="color:#24292E">);</span><span style="color:#6A737D"> // child를 기다린다.</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#D73A49">  return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-bash"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">$</span><span style="color:#032F62"> ./debug</span></span>
<span class="line"><span style="color:#24292E">[SERVER] Child Created.</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">fork()</code>를 수행하면 child 프로세스가 생성된다. fork 이후 코드는 모두 parent와 child에서 동시에 실행된다. parent는 <code style="font-family: RobotoMono,monospace;">wait(NULL)</code>을 통해 child의 작업이 끝날 때까지 대기한다. 이를 이용해 parent에서 사용자로부터 데이터를 입력받고 child에서 출력해보도록 하자.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;stdio.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;unistd.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;sys/wait.h></span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> argc</span><span style="color:#24292E">, </span><span style="color:#D73A49">char*</span><span style="color:#E36209"> argv</span><span style="color:#D73A49">[]</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> cmd </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#D73A49">  pid_t</span><span style="color:#24292E"> pid  </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> fork</span><span style="color:#24292E">();</span><span style="color:#6A737D"> // child를 생성한다.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">  if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">&#x3C;</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // 에러</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[CLIENT] Fork failed.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#D73A49"> if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">==</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // Child (Server)</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[SERVER] Received </span><span style="color:#005CC5">%d</span><span style="color:#032F62">.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">, cmd);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#24292E"> {</span><span style="color:#6A737D"> // Parent (Client)</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[1] search [2] create</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"> "</span><span style="color:#24292E">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1">    scanf</span><span style="color:#24292E">(</span><span style="color:#032F62">"</span><span style="color:#005CC5">%d</span><span style="color:#032F62">"</span><span style="color:#24292E">, </span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">cmd);</span></span>
<span class="line"><span style="color:#6F42C1">    wait</span><span style="color:#24292E">(</span><span style="color:#005CC5">NULL</span><span style="color:#24292E">);</span><span style="color:#6A737D"> // child를 기다린다.</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#D73A49">  return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-bash"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">$</span><span style="color:#032F62"> ./debug</span></span>
<span class="line"><span style="color:#24292E">[1] search [2] create</span></span>
<span class="line"><span style="color:#24292E">[SERVER] Received 0.</span></span>
<span class="line"><span style="color:#D73A49">></span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">안타깝지만 생각대로 동작하지 않는다. 사용자로부터 <code style="font-family: RobotoMono,monospace;">cmd</code>의 값이 할당되는 부분은 parent이며, 변경된 <code style="font-family: RobotoMono,monospace;">cmd</code>는 parent에만 존재한다. 따라서 동시에 실행되고 있는 child에서는 <code style="font-family: RobotoMono,monospace;">cmd</code>의 값이 변경되지 않고 <code style="font-family: RobotoMono,monospace;">0</code>이 출력된다. <code style="font-family: RobotoMono,monospace;">cmd</code> 값을 child에게 전송하고, child가 <code style="font-family: RobotoMono,monospace;">cmd</code>값을 수신할 때까지 대기하는 부분은 따로 구현해야 한다.</p><h2 id="%ED%8C%8C%EC%9D%B4%ED%94%84-%ED%86%B5%EC%8B%A0-%EA%B5%AC%ED%98%84"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">파이프 통신 구현</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">child에게 <code style="font-family: RobotoMono,monospace;">cmd</code> 값을 전송하려면 파이프가 필요하다. 만들어보자.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;stdio.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;unistd.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;sys/wait.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;sys/types.h></span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> argc</span><span style="color:#24292E">, </span><span style="color:#D73A49">char*</span><span style="color:#E36209"> argv</span><span style="color:#D73A49">[]</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> cmd </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#D73A49">  int</span><span style="color:#E36209"> p</span><span style="color:#24292E">[</span><span style="color:#005CC5">2</span><span style="color:#24292E">];</span><span style="color:#6A737D"> // p[0]: read, p[1]: write</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1">  pipe</span><span style="color:#24292E">(p);</span><span style="color:#6A737D"> // 파이프를 생성한다.</span></span>
<span class="line"><span style="color:#D73A49">  pid_t</span><span style="color:#24292E"> pid  </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> fork</span><span style="color:#24292E">();</span><span style="color:#6A737D"> // child를 생성한다.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">  if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">&#x3C;</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // 에러</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[CLIENT] Fork failed.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#D73A49"> if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">==</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // Child (Server)</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[SERVER] Received </span><span style="color:#005CC5">%d</span><span style="color:#032F62">.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">, cmd);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#24292E"> {</span><span style="color:#6A737D"> // Parent (Client)</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[1] search [2] create</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"> "</span><span style="color:#24292E">);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1">    scanf</span><span style="color:#24292E">(</span><span style="color:#032F62">"</span><span style="color:#005CC5">%d</span><span style="color:#032F62">"</span><span style="color:#24292E">, </span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">cmd);</span></span>
<span class="line"><span style="color:#6F42C1">    wait</span><span style="color:#24292E">(</span><span style="color:#005CC5">NULL</span><span style="color:#24292E">);</span><span style="color:#6A737D"> // child를 기다린다.</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#D73A49">  return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">파이프는 단방향 통신만 되기 때문에 읽기 파이프와 쓰기 파이프 두 개가 필요하다. 이제 두 개의 파이프를 만들었으니 child에게 <code style="font-family: RobotoMono,monospace;">cmd</code>를 전송해보자.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;stdio.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;unistd.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;sys/wait.h></span></span>
<span class="line"><span style="color:#D73A49">#include</span><span style="color:#032F62"> &#x3C;sys/types.h></span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> argc</span><span style="color:#24292E">, </span><span style="color:#D73A49">char*</span><span style="color:#E36209"> argv</span><span style="color:#D73A49">[]</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> cmd </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#D73A49">  int</span><span style="color:#E36209"> p</span><span style="color:#24292E">[</span><span style="color:#005CC5">2</span><span style="color:#24292E">];</span><span style="color:#6A737D"> // p[0]: read, p[1]: write</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1">  pipe</span><span style="color:#24292E">(p);</span><span style="color:#6A737D"> // 파이프를 생성한다.</span></span>
<span class="line"><span style="color:#D73A49">  pid_t</span><span style="color:#24292E"> pid  </span><span style="color:#D73A49">=</span><span style="color:#6F42C1"> fork</span><span style="color:#24292E">();</span><span style="color:#6A737D"> // child를 생성한다.</span></span>
<span class="line"></span>
<span class="line"><span style="color:#D73A49">  if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">&#x3C;</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // 에러</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[CLIENT] Fork failed.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#D73A49"> if</span><span style="color:#24292E"> (pid </span><span style="color:#D73A49">==</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">) {</span><span style="color:#6A737D"> // Child (Server)</span></span>
<span class="line"><span style="color:#6F42C1">    read</span><span style="color:#24292E">(</span><span style="color:#E36209">p</span><span style="color:#24292E">[</span><span style="color:#005CC5">0</span><span style="color:#24292E">], </span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">cmd, </span><span style="color:#D73A49">sizeof</span><span style="color:#24292E">(cmd));</span><span style="color:#6A737D"> // 파이프로 전송된 값을 받는다.</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[SERVER] Received </span><span style="color:#005CC5">%d</span><span style="color:#032F62">.</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">, cmd);</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#24292E"> {</span><span style="color:#6A737D"> // Parent (Client)</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"[1] search [2] create</span><span style="color:#005CC5">\n</span><span style="color:#032F62">"</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#6F42C1">    printf</span><span style="color:#24292E">(</span><span style="color:#032F62">"> "</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#6F42C1">    scanf</span><span style="color:#24292E">(</span><span style="color:#032F62">"</span><span style="color:#005CC5">%d</span><span style="color:#032F62">"</span><span style="color:#24292E">, </span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">cmd);</span></span>
<span class="line"></span>
<span class="line"><span style="color:#6F42C1">    write</span><span style="color:#24292E">(</span><span style="color:#E36209">p</span><span style="color:#24292E">[</span><span style="color:#005CC5">1</span><span style="color:#24292E">], </span><span style="color:#D73A49">&#x26;</span><span style="color:#24292E">cmd, </span><span style="color:#D73A49">sizeof</span><span style="color:#24292E">(cmd));</span><span style="color:#6A737D"> // 파이프를 통해 값을 전송한다.</span></span>
<span class="line"><span style="color:#6F42C1">    wait</span><span style="color:#24292E">(</span><span style="color:#005CC5">NULL</span><span style="color:#24292E">);</span><span style="color:#6A737D"> // child를 기다린다.</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#D73A49">  return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-bash"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">$</span><span style="color:#032F62"> ./debug</span></span>
<span class="line"><span style="color:#24292E">[1] search [2] create</span></span>
<span class="line"><span style="color:#D73A49">></span><span style="color:#24292E"> 1</span></span>
<span class="line"><span style="color:#24292E">[SERVER] Received 1.</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">child는 생선된 이후 파이프를 통해 데이터가 전달되기를 기다린다. parent는 사용자에게 <code style="font-family: RobotoMono,monospace;">cmd</code> 값을 입력받고 쓰기 파이프인 <code style="font-family: RobotoMono,monospace;">p[1]</code>를 통해 <code style="font-family: RobotoMono,monospace;">cmd</code> 값을 전송한다. 그리고 수신을 기다리던 child는 <code style="font-family: RobotoMono,monospace;">p[0]</code>을 통해 전달된 <code style="font-family: RobotoMono,monospace;">cmd</code> 값을 읽어들인다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">child 프로세스 생성과 파이프를 통한 두 프로세스의 통신. 핵심적인 부분은 이정도다. 사실 이후 내용은 프로세스를 다루는 것과는 너무 관련이 없어서 제외했다.</p></section><section id="article-navigation"style="margin-top: 50px; overflow: hidden;"><div class="article-navigation-item article-navigation-next"style="margin-bottom: 1rem; text-align: left; float: left; margin-right: 5px;"><a href="4.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-next symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: left; float: left; margin-right: 5px;">←</div><div class="article-navigation-content article-navigation-next"style="text-align: left; float: left; margin-right: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">차이를 중심으로 살펴본 UI디자인과 UX디자인</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">UI는 심미성, UX는 사용성?</p></div></a></div><div class="article-navigation-item article-navigation-prev"style="margin-bottom: 1rem; text-align: right; float: right; margin-left: 5px;"><a href="2.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-prev symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: right; float: right; margin-left: 5px;">→</div><div class="article-navigation-content article-navigation-prev"style="text-align: right; float: right; margin-left: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">♻️ 자바는 어떻게 Garbage Collection을 할까?</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">오브젝트의 일생</p></div></a></div></section><section id="article-comments"><script async src="https://utteranc.es/client.js"repo="parksb/parksb.github.io-comments"issue-term="pathname"theme="github-light"crossorigin="anonymous"></script></section><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div></article></main><footer style="font-size: .8rem; color: #767676;">이 글은 CC BY-NC 4.0 라이선스에 따라 이용할 수 있습니다.</footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-LKTJ5YFJR2"></script><script>window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-LKTJ5YFJR2');</script></body></html>