<!DOCTYPE html><html lang="ko"><head><meta charset="UTF-8"><title>🤖 컴퓨터가 코드를 읽는 아주 구체적인 원리</title><meta name="viewport"content="width=device-width,initial-scale=1"><meta http-equiv="X-UA-Compatible"content="ie=edge"><meta name="theme-color"content="#F5F5F5"><meta name="description"content="지난 학기 운영체제 공부를 하면서 더 낮은 레벨은 어떻게 동작하는지 궁금해졌다. David A. Patterson과 John L. Hennessy의 Computer Organization and Design 5th Edition의 전반부를 바탕으로 MIPS instruction set에 대해 정리했다.Computer Ab..."><link rel="canonical"href="https://parksb.github.io/article/25.html"><meta name="fediverse:creator"content="@parksb@silicon.moe"><meta property="og:title"content="🤖 컴퓨터가 코드를 읽는 아주 구체적인 원리: MIPS 어셈블리어 훑어보기 "><meta property="og:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%F0%9F%A4%96%20%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%80%20%EC%BD%94%EB%93%9C%EB%A5%BC%20%EC%9D%BD%EB%8A%94%20%EC%95%84%EC%A3%BC%20%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8%20%EC%9B%90%EB%A6%AC&subtitle=MIPS%20%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4%20%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0&date=2018.10.16"><meta property="og:description"content="지난 학기 운영체제 공부를 하면서 더 낮은 레벨은 어떻게 동작하는지 궁금해졌다. David A. Patterson과 John L. Hennessy의 Computer Organization and Design 5th Edition의 전반부를 바탕으로 MIPS instruction set에 대해 정리했다.Computer Ab..."><meta name="twitter:title"content="🤖 컴퓨터가 코드를 읽는 아주 구체적인 원리: MIPS 어셈블리어 훑어보기 "><meta name="twitter:image"content="https://og-image-parksb.vercel.app/api/parksb-github-io?title=%F0%9F%A4%96%20%EC%BB%B4%ED%93%A8%ED%84%B0%EA%B0%80%20%EC%BD%94%EB%93%9C%EB%A5%BC%20%EC%9D%BD%EB%8A%94%20%EC%95%84%EC%A3%BC%20%EA%B5%AC%EC%B2%B4%EC%A0%81%EC%9D%B8%20%EC%9B%90%EB%A6%AC&subtitle=MIPS%20%EC%96%B4%EC%85%88%EB%B8%94%EB%A6%AC%EC%96%B4%20%ED%9B%91%EC%96%B4%EB%B3%B4%EA%B8%B0&date=2018.10.16"><meta name="twitter:description"content="지난 학기 운영체제 공부를 하면서 더 낮은 레벨은 어떻게 동작하는지 궁금해졌다. David A. Patterson과 John L. Hennessy의 Computer Organization and Design 5th Edition의 전반부를 바탕으로 MIPS instruction set에 대해 정리했다.Computer Ab..."><meta name="twitter:card"content="summary_large_image"><link rel="shortcut icon"href="../assets/favicon.ico"type="image/x-icon"><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><link rel="preload"href="https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2"as="font"type="font/woff2"crossorigin><style>@font-face { font-family: 'Pretendard'; src: url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/Pretendard/woff2/Pretendard-VF-Distilled.woff2'), local('Pretendard') format('woff2'); font-display: swap; }
      @font-face { font-family: 'RobotoMono'; src: local('RobotoMono'), url('https://cdn.jsdelivr.net/gh/parksb/cdn@master/font/RobotoMono/woff2/RobotoMono-VF-Distilled.woff2') format('woff2'); font-display: swap; }
      a:hover { color: #005ccc !important; }
      #article-content-container a:hover, #article-content-container a:focus { text-decoration: underline !important; }
      #article-content-container .table-of-contents ul li:before { content: counters(item, ".") ". "; counter-increment: item; }
      #article-content-container .footnotes > .footnotes-list > .footnote-item > span { font-size: 0.9rem; }</style></head><body style="font-family: Pretendard,sans-serif; font-size: 16px; margin: 0; padding: 20px 30px 50px 30px; word-break: keep-all;"><header id="top-container"role="navigation"><nav><a class="special-anchor"href="/"style="color: #000; text-decoration: none; cursor: pointer;"><span class="t1"style="font-size: 1.5rem; font-weight: 800;">박성범</span> <span class="t2"style="font-size: 1rem; font-weight: 400;">Simon Park</span></a></nav></header><main id="main-container"style="max-width: 800px; margin-top: 30px; margin-bottom: 30px;"><article id="article-container"><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div><h1 id="article-title"style="margin: 0; padding: 0; font-size: 1.5rem; font-weight: 700;">🤖 컴퓨터가 코드를 읽는 아주 구체적인 원리</h1><h2 id="article-subtitle"style="margin: 0; padding: 0; display: inline; font-size: 1.2rem; font-weight: 400; margin-right: .4rem;">MIPS 어셈블리어 훑어보기</h2><a href="https://github.com/parksb/parksb.github.io/commits/development/_articles/20181016_how-computer-reads-code.md"style="color: #000; text-decoration: none; cursor: pointer;"><time id="article-date"style="font-family: RobotoMono,monospace; font-size: .8rem;">2018.10.16<span class="symbol"style="font-family: Pretendard,sans-serif;">↗</span></time></a><section id="article-content-container"style="margin-top: 30px;"><details style="margin: 0; padding: 0; display: inline; margin-bottom: 10px;"><summary style="font-weight: 700; cursor: pointer;">Table of Contents</summary><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p><div class="table-of-contents"style="font-size: 15px;"><ul style="padding: 0; margin-left: 2rem; list-style-type: none; counter-reset: item; margin: 0; padding-left: 1rem;"><li style="line-height: 1.7rem;"><a href="#computer-abstractions-and-technology"style="text-decoration: none; cursor: pointer; color: #005ccc;">Computer Abstractions and Technology</a><ul style="padding: 0; margin-left: 2rem; list-style-type: none; counter-reset: item; margin: 0; padding-left: 1rem;"><li style="line-height: 1.7rem;"><a href="#instructions%3A-language-of-the-computer"style="text-decoration: none; cursor: pointer; color: #005ccc;">Instructions: Language of the Computer</a></li><li style="line-height: 1.7rem;"><a href="#from-a-high-level-language-to-the-language-of-hardware"style="text-decoration: none; cursor: pointer; color: #005ccc;">From a High-Level Language to the Language of Hardware</a></li><li style="line-height: 1.7rem;"><a href="#operations-of-the-computer-hardware"style="text-decoration: none; cursor: pointer; color: #005ccc;">Operations of the Computer Hardware</a></li></ul></li><li style="line-height: 1.7rem;"><a href="#mips-instructions"style="text-decoration: none; cursor: pointer; color: #005ccc;">MIPS Instructions</a><ul style="padding: 0; margin-left: 2rem; list-style-type: none; counter-reset: item; margin: 0; padding-left: 1rem;"><li style="line-height: 1.7rem;"><a href="#mips-procedure"style="text-decoration: none; cursor: pointer; color: #005ccc;">MIPS Procedure</a></li><li style="line-height: 1.7rem;"><a href="#memory-layout"style="text-decoration: none; cursor: pointer; color: #005ccc;">Memory Layout</a></li><li style="line-height: 1.7rem;"><a href="#mips-instruction-formats"style="text-decoration: none; cursor: pointer; color: #005ccc;">MIPS Instruction Formats</a></li><li style="line-height: 1.7rem;"><a href="#mips-addressing-for-32-bit-immediates-and-addresses"style="text-decoration: none; cursor: pointer; color: #005ccc;">MIPS Addressing for 32-bit Immediates and Addresses</a></li></ul></li></ul></div><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"></p></details><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">지난 학기 <a href="https://parksb.github.io/article/5.html"style="text-decoration: none; cursor: pointer; color: #005ccc;">운영체제</a> 공부를 하면서 더 낮은 레벨은 어떻게 동작하는지 궁금해졌다. David A. Patterson과 John L. Hennessy의 Computer Organization and Design 5th Edition의 전반부를 바탕으로 MIPS instruction set에 대해 정리했다.</p><h2 id="computer-abstractions-and-technology"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">Computer Abstractions and Technology</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">컴퓨터 아키텍처를 공부한다는 것은 <strong>컴퓨터를 구성하는 하드웨어와 명령어가 어떻게 함께 동작하는지 알아보는 것</strong>이다. 하드웨어를 다루기는 하지만 회로에 대한 부분을 자세히 다루지는 않는다. 회로는 로우레벨 아키텍처이고, 앞으로 다룰 내용은 회로(하드웨어)와 운영체제(소프트웨어) 사이에 있는 ISA(Instruction Set Architecture), microarchitecture와 같은 하이레벨 아키텍처다.</p><h3 id="instructions%3A-language-of-the-computer"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">Instructions: Language of the Computer</h3><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><strong>ISA는 <code style="font-family: RobotoMono,monospace;">add</code>, <code style="font-family: RobotoMono,monospace;">load</code>와 같은 명령의 집합</strong>으로, 하드웨어와 소프트웨어 사이의 인터페이스를 정의한다. <strong>microarchitecture는 ISA의 구현체</strong>로, 프로세서와 입출력 subsystem의 조직이다. 파이프라인의 깊이나 캐시 사이즈가 microarchitecture라고 할 수 있다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">머신 설계에는 두 가지 중요한 원칙이 있다. 첫째는 컴퓨터는 모든 것을 bit로 이해하기 때문에 <strong>instruction과 데이터를 구분하지 못한다</strong>는 것이고, 둘째는 <strong>프로그램도 데이터와 똑같이 메모리에 저장된다</strong>는 것이다. 메모리를 여러 구획으로 구분한 것은 인간의 입장이지, 컴퓨터는 결국 바이너리로 받아들인다.</p><h3 id="from-a-high-level-language-to-the-language-of-hardware"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">From a High-Level Language to the Language of Hardware</h3><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> main</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> argc</span><span style="color:#24292E">, </span><span style="color:#D73A49">char</span><span style="color:#D73A49"> *</span><span style="color:#E36209">argv</span><span style="color:#D73A49">[]</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> s0 </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">, s1 </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">, s2 </span><span style="color:#D73A49">=</span><span style="color:#005CC5"> 2</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  s0 </span><span style="color:#D73A49">=</span><span style="color:#24292E"> s1 </span><span style="color:#D73A49">+</span><span style="color:#24292E"> s2;</span></span>
<span class="line"><span style="color:#D73A49">  return</span><span style="color:#005CC5"> 0</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><strong>하이레벨 언어</strong>는 자연어와 가장 가까운 프로그래밍 언어다. 높은 생산성을 제공하며, C, C++, Java 등 흔히 사용되는 프로그래밍 언어들은 대부분 하이레벨 언어다. 하이레벨 언어는 컴파일러를 통해 어셈블리어로 변환된다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">  .data</span></span>
<span class="line"><span style="color:#D73A49">  .text</span></span>
<span class="line"><span style="color:#6F42C1">main</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  add</span><span style="color:#24292E"> $s0, $s1, $s2</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><strong>어셈블리어</strong>는 컴퓨터의 구체적인 동작을 텍스트로 표현한 것으로, instruction의 집합이라고 할 수 있다. 이 단계에서 하이레벨 코드는 명령줄 사이의 점프 수준까지 내려간다. 어셈블리어는 어셈블러에 의해 기계어로 변환된다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>00000000000000000000000000000100</span></span>
<span class="line"><span>00000000000000000000000000000000</span></span>
<span class="line"><span>00000010001100101000000000100000</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><strong>기계어</strong>는 컴퓨터가 이해할 수 있는 바이너리 숫자만으로 구성되어 있다. 컴퓨터는 메모리에 올라간 바이너리 코드를 CPU로 가져와 instruction을 수행한다.</p><h3 id="operations-of-the-computer-hardware"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">Operations of the Computer Hardware</h3><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">여러 종류의 ISA가 있다. 대표적으로 Intel과 AMD에서 만든 x86, AMD64가 있는데, 이들의 CPU 아키텍처는 CISC(Complex Instruction Set Computer) 구조이기 때문에 굉장히 복잡하다. 한편 RISC(Reduced Instruction Set Computer) 구조는 보다 간소하다. RISC 구조인 ARM 아키텍처는 스마트폰이나 태블릿과 같은 모바일 기기에 사용되고 있으며, 2020년에 출시된 M1 맥북도 ARM을 기반으로한 CPU를 사용한다. 우리가 사용할 MIPS(Microprocessor without Interlocked Pipeline Stages)도 RISC 구조 아키텍처다. MIPS는 명령어 세트가 깔끔해 컴퓨터 아키텍처를 공부하는 목적으로 적합하며, 실제로는 블루레이 기기나 플레이스테이션과 같은 디지털 홈, 네트워킹 장비에 사용되었다.</p><h2 id="mips-instructions"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.4rem; padding-bottom: 5px; border-bottom: 1px #000 solid;">MIPS Instructions</h2><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">앞서 하이레벨 언어가 어셈블리어로, 어셈블리어가 최종적으로 기계어로 변환된다는 것을 보았다. 하이레벨 언어는 알고 있다는 가정하에, 실제 MIPS에서 instruction이 어떻게 작성되는지, 그 instruction이 어떤 규칙에 따라 기계어로 변환되는 지 알아보자.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">먼저 CPU가 매번 메인메모리에서 값을 읽어오는 것은 오버헤드가 큰 일이기 때문에 CPU는 <strong>레지스터라는 작고 빠른 메모리</strong>를 가지고 있다. 크기는 작지만 속도가 빨라서 레지스터에 데이터를 두면 instruction을 빠르게 수행할 수 있다. MIPS의 연산은 32x32bit 레지스터를 사용하며, <strong>32bit 데이터를 word라고 부른다.</strong> 레지스터의 일부에는 미리 이름을 붙여 놓았는데, <code style="font-family: RobotoMono,monospace;">$t0</code>부터 <code style="font-family: RobotoMono,monospace;">$t9</code>까지는 임시 레지스터(temporary register)를 의미하며, <code style="font-family: RobotoMono,monospace;">$s0</code>부터 <code style="font-family: RobotoMono,monospace;">$s7</code>까지는 계속 사용되는 레지스터(saved register)를 의미한다.</p><h4 id="arithmetic-operations"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Arithmetic Operations</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">산술 연산은 그리 복잡하지 않다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#24292E">a </span><span style="color:#D73A49">=</span><span style="color:#24292E"> (b </span><span style="color:#D73A49">+</span><span style="color:#24292E"> c) </span><span style="color:#D73A49">-</span><span style="color:#24292E"> (d </span><span style="color:#D73A49">+</span><span style="color:#24292E"> e);</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">a</code>, <code style="font-family: RobotoMono,monospace;">b</code>, <code style="font-family: RobotoMono,monospace;">c</code>, <code style="font-family: RobotoMono,monospace;">d</code>, <code style="font-family: RobotoMono,monospace;">e</code>가 각각 레지스터 <code style="font-family: RobotoMono,monospace;">$s0</code>, <code style="font-family: RobotoMono,monospace;">$s1</code>, <code style="font-family: RobotoMono,monospace;">$s2</code>, <code style="font-family: RobotoMono,monospace;">$s3</code>, <code style="font-family: RobotoMono,monospace;">$s4</code>에 대응된다고 하면 MIPS 코드는 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $t0, $s1, $s2 </span><span style="color:#6A737D"># $t0 = $s1 + $s2</span></span>
<span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $t1, $s3, $s4 </span><span style="color:#6A737D"># $t1 = $s3 + $s3</span></span>
<span class="line"><span style="color:#005CC5">sub</span><span style="color:#24292E"> $s0, $t0, $t1 </span><span style="color:#6A737D"># $s0 = $t0 - $t1</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">add</code>는 값을 덧셈을, <code style="font-family: RobotoMono,monospace;">sub</code>는 뺄셈을 수행한다.</p><h4 id="memory-operations"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Memory Operations</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">MIPS의 메모리 연산은 메모리에서 레지스터로, 레지스터에서 메모리로 데이터를 옮기는 일을 한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#24292E">a </span><span style="color:#D73A49">=</span><span style="color:#24292E"> b </span><span style="color:#D73A49">+</span><span style="color:#E36209"> A</span><span style="color:#24292E">[</span><span style="color:#005CC5">8</span><span style="color:#24292E">]</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">a</code>, <code style="font-family: RobotoMono,monospace;">b</code>은 각각 <code style="font-family: RobotoMono,monospace;">$s1</code>, <code style="font-family: RobotoMono,monospace;">$s2</code>에 대응되고, <code style="font-family: RobotoMono,monospace;">A</code>의 <strong>base address</strong>가 <code style="font-family: RobotoMono,monospace;">$s3</code>에 대응된다고 하면 MIPS 코드는 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">32</span><span style="color:#24292E">($s3) </span><span style="color:#6A737D"># $t0 = $s3[8]</span></span>
<span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $s1, $s2, $t0 </span><span style="color:#6A737D"># $s1 = $s2 + $t0</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">lw</code>는 메모리에서 레지스터로 값을 가져온다. 정수 배열의 원소들은 메모리상에 각자 1word(4bytes)씩 차지하며 저장된다. 즉, <code style="font-family: RobotoMono,monospace;">A[8]</code>는 메모리 상에 다음과 같이 존재한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>4byte   4byte     4byte          4byte</span></span>
<span class="line"><span>A[0],   A[1],     A[2],    ...,  A[8]</span></span>
<span class="line"><span>$s3,    4($s3),   8($s3),  ...,  32($s3)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">따라 <code style="font-family: RobotoMono,monospace;">32($s3)</code>은 base address <code style="font-family: RobotoMono,monospace;">$s3</code>에서 32bytes 떨어진 위치에 접근한다는 의미가 된다. 이때 앞에 붙는 숫자를 <strong>offset</strong>이라고 하며, base address를 가리키는 레지스터(위 경우 <code style="font-family: RobotoMono,monospace;">$s3</code>)는 <strong>base register</strong>라고 한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#E36209">A</span><span style="color:#24292E">[</span><span style="color:#005CC5">12</span><span style="color:#24292E">] </span><span style="color:#D73A49">=</span><span style="color:#24292E"> a </span><span style="color:#D73A49">+</span><span style="color:#E36209"> A</span><span style="color:#24292E">[</span><span style="color:#005CC5">8</span><span style="color:#24292E">]</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">a</code>가 <code style="font-family: RobotoMono,monospace;">$s2</code>, A의 base address가 <code style="font-family: RobotoMono,monospace;">$s3</code>에 대응된다고 하면 MIPS 코드는 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">32</span><span style="color:#24292E">($s3) </span><span style="color:#6A737D"># $t0 = $s3[8]</span></span>
<span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $t0, $s2, $t0 </span><span style="color:#6A737D"># $t0 = $s2 + $t0</span></span>
<span class="line"><span style="color:#005CC5">sw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">48</span><span style="color:#24292E">($s3) </span><span style="color:#6A737D"># A[12] = $t0</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">sw</code>는 레지스터에서 메모리로 데이터를 옮긴다. 위에서는 <code style="font-family: RobotoMono,monospace;">lw</code>로 메모리에서 <code style="font-family: RobotoMono,monospace;">32($s3)</code> 값을 가져와 레지스터의 <code style="font-family: RobotoMono,monospace;">$t0</code>에 저장했고, 아래에서는 <code style="font-family: RobotoMono,monospace;">$t0</code>의 값을 메모리의 <code style="font-family: RobotoMono,monospace;">48($s3)</code> 위치에 저장했다.</p><h4 id="immediate-instructions"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Immediate Instructions</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">상수를 더할 때는 <code style="font-family: RobotoMono,monospace;">addi</code>를 사용한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">addi</span><span style="color:#24292E"> $s3, $s3, </span><span style="color:#005CC5">4</span><span style="color:#6A737D"> # $s3 = $s3 + 4</span></span>
<span class="line"><span style="color:#005CC5">addi</span><span style="color:#24292E"> $s2, $s2, -</span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $s2 = $s2 + (-1)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">상수에 대한 뺄셈 연산은 따로 없기 때문에 음수를 더해주면 된다.</p><h4 id="constant"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Constant</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">MIPS 레지스터 <code style="font-family: RobotoMono,monospace;">$zero</code>는 상수 0을 의미한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $t0, $s1, $zero </span><span style="color:#6A737D"># $t0 = $s1 + 0</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">위 처럼 다른 레지스터로 값을 그대로 대입할 때 사용할 수 있다.</p><h4 id="conditional-statement"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Conditional Statement</h4><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">if</span><span style="color:#24292E"> (i </span><span style="color:#D73A49">==</span><span style="color:#24292E"> j) {</span></span>
<span class="line"><span style="color:#24292E">  a </span><span style="color:#D73A49">=</span><span style="color:#24292E"> b </span><span style="color:#D73A49">+</span><span style="color:#24292E"> c;</span></span>
<span class="line"><span style="color:#24292E">} </span><span style="color:#D73A49">else</span><span style="color:#24292E"> {</span></span>
<span class="line"><span style="color:#24292E">  a </span><span style="color:#D73A49">=</span><span style="color:#24292E"> b </span><span style="color:#D73A49">-</span><span style="color:#24292E"> c;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">a</code>, <code style="font-family: RobotoMono,monospace;">b</code>, <code style="font-family: RobotoMono,monospace;">c</code>, <code style="font-family: RobotoMono,monospace;">i</code>, <code style="font-family: RobotoMono,monospace;">j</code>가 각각 <code style="font-family: RobotoMono,monospace;">$s0</code>부터 <code style="font-family: RobotoMono,monospace;">$s4</code>에 대응된다고 하면 MIPS 코드는 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">  bne</span><span style="color:#24292E"> $s3, $s4, Else </span><span style="color:#6A737D"># if ($s3 == $s4)</span></span>
<span class="line"><span style="color:#005CC5">  add</span><span style="color:#24292E"> $s0, $s1, $s2 </span><span style="color:#6A737D"># { $s0 = $s1 + $s2 }</span></span>
<span class="line"><span style="color:#005CC5">  j</span><span style="color:#24292E"> Exit</span></span>
<span class="line"><span style="color:#6F42C1">Else</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  sub</span><span style="color:#24292E"> $s0, $s1, $s2 </span><span style="color:#6A737D"># else { $s0 = $s1 - $s2 }</span></span>
<span class="line"><span style="color:#6F42C1">Exit</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#24292E">  ...</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">bne</code>는 두 레지스터 값이 같은지 비교해 같다면 다음 구문을, 다르다면 지정된 라벨로 점프한다. 위에서는 <code style="font-family: RobotoMono,monospace;">bne</code>를 통해 <code style="font-family: RobotoMono,monospace;">$s3</code>와 <code style="font-family: RobotoMono,monospace;">$s4</code>가 같은지 비교한 뒤, 다르다면 <code style="font-family: RobotoMono,monospace;">Else</code> 라벨로 점프해 <code style="font-family: RobotoMono,monospace;">sub $s0, $s1, $s2</code>를 실행하도록 했다. 라벨 이름은 개발자가 임의로 정할 수 있다. 꼭 <code style="font-family: RobotoMono,monospace;">Else</code>나 <code style="font-family: RobotoMono,monospace;">Exit</code>라는 이름일 필요는 없다는 것이다. 또한 라벨의 위치는 어셈블러가 계산한다.</p><h4 id="loop"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Loop</h4><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">while</span><span style="color:#24292E"> (</span><span style="color:#E36209">save</span><span style="color:#24292E">[i] </span><span style="color:#D73A49">==</span><span style="color:#24292E"> k) {</span></span>
<span class="line"><span style="color:#24292E">  i </span><span style="color:#D73A49">+=</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">i</code>, <code style="font-family: RobotoMono,monospace;">k</code>가 각각 <code style="font-family: RobotoMono,monospace;">$s3</code>, <code style="font-family: RobotoMono,monospace;">$s5</code>에, <code style="font-family: RobotoMono,monospace;">save</code>의 base address가 <code style="font-family: RobotoMono,monospace;">$s6</code>에 대응된다고 하면 MIPS 코드는 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">Loop</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  sll</span><span style="color:#24292E"> $t1, $s3, </span><span style="color:#005CC5">2</span><span style="color:#6A737D"> # $t1 = $s3 &#x3C;&#x3C; 2</span></span>
<span class="line"><span style="color:#005CC5">  add</span><span style="color:#24292E"> $t1, $t1, $s6 </span><span style="color:#6A737D"># $t1 = $t1($s6)</span></span>
<span class="line"><span style="color:#005CC5">  lw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($t1) </span><span style="color:#6A737D"># $t0 = 0($t1)</span></span>
<span class="line"><span style="color:#005CC5">  bne</span><span style="color:#24292E"> $t0, $s5, Exit </span><span style="color:#6A737D"># if ($t0 != $s5) { goto Exit }</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $s3, $s3, </span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $s3 += 1</span></span>
<span class="line"><span style="color:#005CC5">  j</span><span style="color:#24292E"> Loop</span></span>
<span class="line"><span style="color:#6F42C1">Exit</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#24292E">  ...</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">상당히 복잡한데, 크게 두 부분으로 나눌 수 있다. <code style="font-family: RobotoMono,monospace;">bne</code>부터 <code style="font-family: RobotoMono,monospace;">j</code> 라인까지는 루프의 조건을 확인하고 <code style="font-family: RobotoMono,monospace;">i</code> 값을 증가시키는 부분이다. 그 위의 <code style="font-family: RobotoMono,monospace;">sll</code>부터 <code style="font-family: RobotoMono,monospace;">lw</code> 라인까지는 레지스터에 <code style="font-family: RobotoMono,monospace;">save[i]</code> 값을 가져오는 부분이다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">sll</code> 자체는 control flow에 중요한 instruction이 아니고, 단순히 값을 left shift하는 기능을 한다. <code style="font-family: RobotoMono,monospace;">$s3</code>의 값을 2만큼 left shift하면 4를 곱하는 것과 같다. 이는 <code style="font-family: RobotoMono,monospace;">$s3</code> 값이 1증가할 때마다 4를 곱함으로써 <code style="font-family: RobotoMono,monospace;">$s6</code>에 접근하는 주소값을 4bytes씩 옮기기 위한 코드다. right shift를 하기 위해서는 <code style="font-family: RobotoMono,monospace;">srl</code>을 사용한다.</p><h3 id="mips-procedure"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">MIPS Procedure</h3><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">procedure는 함수를 의미한다. 어셈블리 레벨에서 함수를 만들고 호출하는 것은 하이레벨 언어에서 하던 것과는 많이 다르다. 여기서 가장 중요한 것은 레지스터의 백업과 점프다.</p><h4 id="leaf-procedure"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Leaf Procedure</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">호출된 함수에서 다른 함수를 호출하지 않는 함수, 즉 <strong>leaf procedure</strong>를 가정해보자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> leaf_procedure</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> a</span><span style="color:#24292E">, b, c, d) {</span></span>
<span class="line"><span style="color:#D73A49">  int</span><span style="color:#24292E"> e;</span></span>
<span class="line"><span style="color:#24292E">  e </span><span style="color:#D73A49">=</span><span style="color:#24292E"> (a </span><span style="color:#D73A49">+</span><span style="color:#24292E"> b) </span><span style="color:#D73A49">-</span><span style="color:#24292E"> (c </span><span style="color:#D73A49">-</span><span style="color:#24292E">d);</span></span>
<span class="line"><span style="color:#D73A49">  return</span><span style="color:#24292E"> e;</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">a</code>부터 <code style="font-family: RobotoMono,monospace;">d</code>까지가 <code style="font-family: RobotoMono,monospace;">$a0</code>부터 <code style="font-family: RobotoMono,monospace;">$a3</code>에 대응되고, <code style="font-family: RobotoMono,monospace;">e</code>는 <code style="font-family: RobotoMono,monospace;">$s0</code>에 대응된다고 하면 MIPS 코드는 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">main</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  jal</span><span style="color:#24292E"> leaf_procedure </span><span style="color:#6A737D"># leaf_procedure 호출</span></span>
<span class="line"><span style="color:#005CC5">  j</span><span style="color:#24292E"> exit</span></span>
<span class="line"><span style="color:#6F42C1">leaf_procedure</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, -</span><span style="color:#005CC5">12</span><span style="color:#6A737D"> # 4bytes 레지스터 3개 백업을 위해 stack pointer 위치 -12 이동</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $t1, </span><span style="color:#005CC5">8</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># 8($sp) = $t1</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># 4($sp) = $t0</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $s0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># 0($sp) = $s0</span></span>
<span class="line"><span style="color:#005CC5">  add</span><span style="color:#24292E"> $t0, $a0, $a1</span></span>
<span class="line"><span style="color:#005CC5">  add</span><span style="color:#24292E"> $t1, $a2, $a3</span></span>
<span class="line"><span style="color:#005CC5">  sub</span><span style="color:#24292E"> $s0, $t0, $t1</span></span>
<span class="line"><span style="color:#005CC5">  add</span><span style="color:#24292E"> $v0, $s0, $zero</span></span>
<span class="line"><span style="color:#005CC5">  lw</span><span style="color:#24292E"> $s0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># $s0 = 0($sp)</span></span>
<span class="line"><span style="color:#005CC5">  lw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># $t0 = 4($sp)</span></span>
<span class="line"><span style="color:#005CC5">  lw</span><span style="color:#24292E"> $t1, </span><span style="color:#005CC5">8</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># $t1 = 8($sp)</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, </span><span style="color:#005CC5">12</span><span style="color:#6A737D"> # stack pointer 위치 복원</span></span>
<span class="line"><span style="color:#005CC5">  jr</span><span style="color:#24292E"> $ra </span><span style="color:#6A737D"># $ra 위치로 점프</span></span>
<span class="line"><span style="color:#6F42C1">exit</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#24292E">  ...</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">…왜 이런 짓을 하는걸까? 하나씩 살펴보자.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">main</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  jal</span><span style="color:#24292E"> leaf_procedure </span><span style="color:#6A737D"># leaf_procedure 호출</span></span>
<span class="line"><span style="color:#005CC5">  j</span><span style="color:#24292E"> exit</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">먼저 <code style="font-family: RobotoMono,monospace;">jal</code>을 통해 <code style="font-family: RobotoMono,monospace;">leaf_procedure</code> 라벨로 이동한다. 이때, 레지스터의 <code style="font-family: RobotoMono,monospace;">$ra</code>(return address)는 program counter의 값을 가져온다. program counter는 프로세스가 자신의 instruction을 어디까지 실행했는지 체크하기 위한 값이다. 이 경우 <code style="font-family: RobotoMono,monospace;">$ra</code>는 <code style="font-family: RobotoMono,monospace;">jal leaf_procedure</code> 바로 다음 라인 <code style="font-family: RobotoMono,monospace;">j exit</code>를 가리킨다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">leaf_procedure</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, -</span><span style="color:#005CC5">12</span><span style="color:#6A737D"> # 4bytes 레지스터 3개 백업을 위해 stack pointer 위치 -12 이동</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">leaf_proceduer</code>에서는 먼저 레지스터의 <code style="font-family: RobotoMono,monospace;">$sp</code>(stack pointer)에 4bytes 레지스터 3개를 백업하기 위해 <code style="font-family: RobotoMono,monospace;">$sp</code>에 <code style="font-family: RobotoMono,monospace;">-12</code>를 더했다. <code style="font-family: RobotoMono,monospace;">$sp</code>는 메모리의 스택의 특정 주소를 가리키는 레지스터이며, 이 위치를 옮기는 것은 백업을 위한 공간을 확보하는 것이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">sw</span><span style="color:#24292E"> $t1, </span><span style="color:#005CC5">8</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># 8($sp) = $t1</span></span>
<span class="line"><span style="color:#005CC5">sw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># 4($sp) = $t0</span></span>
<span class="line"><span style="color:#005CC5">sw</span><span style="color:#24292E"> $s0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># 0($sp) = $s0</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">그리고 <code style="font-family: RobotoMono,monospace;">sw</code>를 통해 <code style="font-family: RobotoMono,monospace;">$t1</code>, <code style="font-family: RobotoMono,monospace;">$t0</code>, <code style="font-family: RobotoMono,monospace;">$s0</code>를 <code style="font-family: RobotoMono,monospace;">$sp</code>의 각 공간에 담았다. (큰 값부터 접근하는 이유는 메모리의 스택 주소가 큰 쪽에서 작은 쪽으로 향하기 때문이다.) 이렇게 하는 이유는 <code style="font-family: RobotoMono,monospace;">leaf_procedure</code>를 호출한 caller측(이 경우 <code style="font-family: RobotoMono,monospace;">main</code>)에서 <code style="font-family: RobotoMono,monospace;">$t1</code>이나 <code style="font-family: RobotoMono,monospace;">$t0</code>, <code style="font-family: RobotoMono,monospace;">$s0</code> 레지스터를 사용하고 있을 수도 있기 때문이다. 만약 스택에 백업하지 않는다면 caller에서 사용하던 값을 덮어씌워 버릴 것이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $t0, $a0, $a1</span></span>
<span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $t1, $a2, $a3</span></span>
<span class="line"><span style="color:#005CC5">sub</span><span style="color:#24292E"> $s0, $t0, $t1</span></span>
<span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $v0, $s0, $zero</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">e = (a + b) - (c -d)</code>에 해당하는 연산을 수행한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $s0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># $s0 = 0($sp)</span></span>
<span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># $t0 = 4($sp)</span></span>
<span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $t1, </span><span style="color:#005CC5">8</span><span style="color:#24292E">($sp) </span><span style="color:#6A737D"># $t1 = 8($sp)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">lw</code>를 통해 <code style="font-family: RobotoMono,monospace;">$sp</code>에 저장한 값을 다시 불러왔다. stack pointer도 다시 12bytes 당겼다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">jr</span><span style="color:#24292E"> $ra </span><span style="color:#6A737D"># $ra 위치로 점프</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">jr</code>을 통해 caller에 위치한 <code style="font-family: RobotoMono,monospace;">$ra</code>로 돌아가 <code style="font-family: RobotoMono,monospace;">j exit</code>를 실행한다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">여기서는 <code style="font-family: RobotoMono,monospace;">$t1</code>과 <code style="font-family: RobotoMono,monospace;">$t0</code>도 백업을 했는데, 사실 이럴 필요는 없다. <code style="font-family: RobotoMono,monospace;">$t</code> 레지스터는 temporary register이기 때문에 언제나 임시 값만 저장하도록 약속되어있다. 따라서 <code style="font-family: RobotoMono,monospace;">$t</code> 레지스터에는 값이 덮어씌워져도 문제가 없도록 코드를 짜야한다.</p><h4 id="non-leaf-procedure"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">Non-Leaf Procedure</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">함수 안에서 다른 함수를 호출하는 non-leaf procedure는 어떨까? 이렇게 호출이 중첩된 경우에는 <code style="font-family: RobotoMono,monospace;">$ra</code>에 저장된 callr의 위치가 덮어 씌워져 무한 루프에 빠질 위험이 있다. 일단 하이레벨 코드를 보자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-c"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#D73A49">int</span><span style="color:#6F42C1"> factorial</span><span style="color:#24292E">(</span><span style="color:#D73A49">int</span><span style="color:#E36209"> n</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">  if</span><span style="color:#24292E"> (n </span><span style="color:#D73A49">&#x3C;</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">) {</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">;</span></span>
<span class="line"><span style="color:#24292E">  } </span><span style="color:#D73A49">else</span><span style="color:#24292E"> {</span></span>
<span class="line"><span style="color:#D73A49">    return</span><span style="color:#24292E"> n </span><span style="color:#D73A49">*</span><span style="color:#6F42C1"> factorial</span><span style="color:#24292E">(n </span><span style="color:#D73A49">-</span><span style="color:#005CC5"> 1</span><span style="color:#24292E">);</span></span>
<span class="line"><span style="color:#24292E">  }</span></span>
<span class="line"><span style="color:#24292E">}</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">recursive하게 동작하는 팩토리얼 함수다. <code style="font-family: RobotoMono,monospace;">n</code>이 <code style="font-family: RobotoMono,monospace;">$a0</code>에, 결과값이 <code style="font-family: RobotoMono,monospace;">$v0</code>에 대응된다고 가정하면 MIPS 코드는 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">factorial</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, -</span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 -8 이동</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  slti</span><span style="color:#24292E"> $t0, $a0, </span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $t0 = ($a0 &#x3C; 1)</span></span>
<span class="line"><span style="color:#005CC5">  beq</span><span style="color:#24292E"> $t0, $zero, L1 </span><span style="color:#6A737D"># if ($t0 == 0) { goto L1 }</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $v0, $zero, </span><span style="color:#005CC5">1</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, </span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 8 이동</span></span>
<span class="line"><span style="color:#005CC5">  jr</span><span style="color:#24292E"> $ra</span></span>
<span class="line"><span style="color:#6F42C1">L1</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $a0, $a0, -</span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $a -= 1</span></span>
<span class="line"><span style="color:#005CC5">  jal</span><span style="color:#24292E"> factorial </span><span style="color:#6A737D"># factorial($a0)</span></span>
<span class="line"><span style="color:#005CC5">  lw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  lw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, </span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 8 이동</span></span>
<span class="line"><span style="color:#005CC5">  mul</span><span style="color:#24292E"> $v0, $a0, $v0 </span><span style="color:#6A737D"># $v0 = $a0 * $v0</span></span>
<span class="line"><span style="color:#005CC5">  jr</span><span style="color:#24292E"> $ra</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">굉장히 복잡해보이지만, 하나씩 뜯어보면… 진짜 복잡하다. 작동 방식은 대략 재귀적으로 함수를 호출하면서 stack pointer를 밀어내며 값을 백업하다가, 이후 다시 stack pointer를 당기며 값을 가져와 결과를 내는 식이다. <code style="font-family: RobotoMono,monospace;">$a0</code>가 3이라고 가정하고 모든 instruction 단계를 step by step으로 한 단계 한 단계 살펴보자.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">factorial</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, -</span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 -8 이동</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">먼저 <code style="font-family: RobotoMono,monospace;">factorial</code> 함수에 진입해 stack pointer를 이동시키고 <code style="font-family: RobotoMono,monospace;">$ra</code>와 <code style="font-family: RobotoMono,monospace;">$a0</code> 레지스터를 백업했다. 이때 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 <code style="font-family: RobotoMono,monospace;">factorial</code> 함수를 호출한 위치</strong>가 될 것이고, <strong><code style="font-family: RobotoMono,monospace;">$a0</code>는 앞서 가정한 3</strong>이 된다. 스택의 모습은 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+--------+------------+</span></span>
<span class="line"><span>| $a = 3 | caller $ra |</span></span>
<span class="line"><span>+--------+------------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이제 다음 라인을 보자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">slti</span><span style="color:#24292E"> $t0, $a0, </span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $t0 = ($a0 &#x3C; 1)</span></span>
<span class="line"><span style="color:#005CC5">beq</span><span style="color:#24292E"> $t0, $zero, L1 </span><span style="color:#6A737D"># if ($t0 == 0) { goto L1 }</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">$a0</code>가 1보다 작은지 확인하고, 그 반환 값을 <code style="font-family: RobotoMono,monospace;">$t0</code>에 저장한다. 그리고 <code style="font-family: RobotoMono,monospace;">$t0</code>가 <code style="font-family: RobotoMono,monospace;">$zero</code>와 같은지 확인해 값이 같다면 <code style="font-family: RobotoMono,monospace;">L1</code> 라벨로 이동한다. 이때 <strong><code style="font-family: RobotoMono,monospace;">$a0</code>는 3</strong>이기 때문에 1보다 작지 않다. 따라서 <strong><code style="font-family: RobotoMono,monospace;">$t0</code>는 0</strong>이 되고, <code style="font-family: RobotoMono,monospace;">beq</code>를 만족해 <code style="font-family: RobotoMono,monospace;">L1</code>으로 넘어간다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">L1</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $a0, $a0, -</span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $a -= 1</span></span>
<span class="line"><span style="color:#005CC5">  jal</span><span style="color:#24292E"> factorial </span><span style="color:#6A737D"># factorial($a0)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">L1</code>은 하이레벨 코드에서 <code style="font-family: RobotoMono,monospace;">return n * factorial(n - 1);</code>에 해당하는 동작을 정의한다. 먼저 <code style="font-family: RobotoMono,monospace;">$a0</code>에서 1을 뺀다. 그리고 다시 <code style="font-family: RobotoMono,monospace;">factorial</code> 함수를 호출한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">factorial</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, -</span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 -8 이동</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">factorial</code>은 <code style="font-family: RobotoMono,monospace;">$sp</code>를 다시 -8 이동한다. 그리고 <code style="font-family: RobotoMono,monospace;">$ra</code>와 <code style="font-family: RobotoMono,monospace;">$a0</code>를 백업한다. 이때 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 앞서 실행한 <code style="font-family: RobotoMono,monospace;">L1</code>의 <code style="font-family: RobotoMono,monospace;">jal factorial</code>의 바로 다음 라인</strong>이고, <strong><code style="font-family: RobotoMono,monospace;">$a0</code>는 2</strong>가 된다. 현재 스택에 저장된 레지스터 값을 표현하면 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+--------+------------+--------+--------+</span></span>
<span class="line"><span>| $a = 3 | caller $ra | $a = 2 | L1 $ra |</span></span>
<span class="line"><span>+--------+------------+--------+--------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이어서 다음 라인을 살펴보자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">slti</span><span style="color:#24292E"> $t0, $a0, </span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $t0 = ($a0 &#x3C; 1)</span></span>
<span class="line"><span style="color:#005CC5">beq</span><span style="color:#24292E"> $t0, $zero, L1 </span><span style="color:#6A737D"># if ($t0 == 0) { goto L1 }</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">$a0</code>가 2이므로 1보다 작지 않다. <code style="font-family: RobotoMono,monospace;">$t0</code>가 0이 되고, <code style="font-family: RobotoMono,monospace;">beq</code>를 만족해 다시 <code style="font-family: RobotoMono,monospace;">L1</code>으로 넘어간다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">L1</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $a0, $a0, -</span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $a -= 1</span></span>
<span class="line"><span style="color:#005CC5">  jal</span><span style="color:#24292E"> factorial </span><span style="color:#6A737D"># factorial($a0)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">L1</code>은 아까와 마찬가지로 <code style="font-family: RobotoMono,monospace;">$a</code>에서 1을 빼 1로 만들고, 다시 <code style="font-family: RobotoMono,monospace;">factorial</code>로 넘어간다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">factorial</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, -</span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 -8 이동</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">factorial</code>에서는 <code style="font-family: RobotoMono,monospace;">$sp</code>를 다시 -8 이동한다. 이때 백업되는 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 앞서 실행한 <code style="font-family: RobotoMono,monospace;">L1</code>의 <code style="font-family: RobotoMono,monospace;">jal factorial</code>의 바로 다음 라인</strong>이고, <strong><code style="font-family: RobotoMono,monospace;">$a0</code>는 1</strong>이다. 현재 스택에 저장된 레지스터 값은 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+--------+------------+--------+--------+--------+--------+</span></span>
<span class="line"><span>| $a = 3 | caller $ra | $a = 2 | L1 $ra | $a = 1 | L1 $ra |</span></span>
<span class="line"><span>+--------+------------+--------+--------+--------+--------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">다음 라인으로 넘어가자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">slti</span><span style="color:#24292E"> $t0, $a0, </span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $t0 = ($a0 &#x3C; 1)</span></span>
<span class="line"><span style="color:#005CC5">beq</span><span style="color:#24292E"> $t0, $zero, L1 </span><span style="color:#6A737D"># if ($t0 == 0) { goto L1 }</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">여전히 <code style="font-family: RobotoMono,monospace;">$a0</code>가 1이므로 1보다 작지 않고, <code style="font-family: RobotoMono,monospace;">beq</code>를 만족해 <code style="font-family: RobotoMono,monospace;">L1</code>으로 넘어간다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">L1</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $a0, $a0, -</span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $a -= 1</span></span>
<span class="line"><span style="color:#005CC5">  jal</span><span style="color:#24292E"> factorial </span><span style="color:#6A737D"># factorial($a0)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">L1</code>은 <code style="font-family: RobotoMono,monospace;">$a</code>에서 1을 빼 0으로 만들고, <code style="font-family: RobotoMono,monospace;">factorial</code>로 넘어간다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">factorial</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $sp, $sp, -</span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 -8 이동</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">  sw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">factorial</code>에서는 또 다시 <code style="font-family: RobotoMono,monospace;">$sp</code>를 -8 이동한다. 이때 백업되는 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 앞서 실행한 <code style="font-family: RobotoMono,monospace;">L1</code>의 <code style="font-family: RobotoMono,monospace;">jal factorial</code>의 바로 다음 라인</strong>이고, <strong><code style="font-family: RobotoMono,monospace;">$a0</code>는 0</strong>이다. 현재 스택에 저장된 레지스터 값은 다음과 같다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+--------+------------+--------+--------+--------+--------+--------+--------+</span></span>
<span class="line"><span>| $a = 3 | caller $ra | $a = 2 | L1 $ra | $a = 1 | L1 $ra | $a = 0 | L1 $ra |</span></span>
<span class="line"><span>+--------+------------+--------+--------+--------+--------+--------+--------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">다음 라인을 보자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">slti</span><span style="color:#24292E"> $t0, $a0, </span><span style="color:#005CC5">1</span><span style="color:#6A737D"> # $t0 = ($a0 &#x3C; 1)</span></span>
<span class="line"><span style="color:#005CC5">beq</span><span style="color:#24292E"> $t0, $zero, L1 </span><span style="color:#6A737D"># if ($t0 == 0) { goto L1 }</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이젠 <strong><code style="font-family: RobotoMono,monospace;">$a0</code>가 0</strong>이므로 1보다 작아 <strong><code style="font-family: RobotoMono,monospace;">$t0</code>가 1</strong>이 된다. <code style="font-family: RobotoMono,monospace;">beq</code>를 만족하지 않으므로 <code style="font-family: RobotoMono,monospace;">L1</code>으로 넘어가지 않고 다음 라인을 실행한다. 여기까지 호출 과정이었고, 이제는 반환 값을 받아오는 과정을 반복한다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">addi</span><span style="color:#24292E"> $v0, $zero, </span><span style="color:#005CC5">1</span></span>
<span class="line"><span style="color:#005CC5">addi</span><span style="color:#24292E"> $sp, $sp, </span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 8 이동</span></span>
<span class="line"><span style="color:#005CC5">jr</span><span style="color:#24292E"> $ra</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">$v0</code>에 0에 1을 더한 값, 즉 1을 저장한다. 그리고 stack pointer 위치를 8만큼 당기고 <code style="font-family: RobotoMono,monospace;">$ra</code> 위치로 넘어간다. 이때 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 <code style="font-family: RobotoMono,monospace;">L1 $ra</code> 위치</strong>다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+--------+------------+--------+--------+--------+--------+</span></span>
<span class="line"><span>| $a = 3 | caller $ra | $a = 2 | L1 $ra | $a = 1 | L1 $ra |</span></span>
<span class="line"><span>+--------+------------+--------+--------+--------+--------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">stack pointer 위치를 8만큼 당겼으니 스택의 모습은 위와 같이 된다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">addi</span><span style="color:#24292E"> $sp, $sp, </span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 8 이동</span></span>
<span class="line"><span style="color:#005CC5">mul</span><span style="color:#24292E"> $v0, $a0, $v0 </span><span style="color:#6A737D"># $v0 = $a0 * $v0</span></span>
<span class="line"><span style="color:#005CC5">jr</span><span style="color:#24292E"> $ra</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">스택에서 <code style="font-family: RobotoMono,monospace;">$a0</code> 값과 <code style="font-family: RobotoMono,monospace;">$ra</code> 값을 가져온다. 앞선 스택의 모습을 확인해보면 <strong><code style="font-family: RobotoMono,monospace;">$a0</code>가 1</strong>이고 <code style="font-family: RobotoMono,monospace;">$ra</code>는 <strong><code style="font-family: RobotoMono,monospace;">L1 $ra</code> 위치</strong>다. 그리고 다시 stack pointer의 위치를 8 움직인다. 이어서 <code style="font-family: RobotoMono,monospace;">$v0</code>에 <code style="font-family: RobotoMono,monospace;">$a0 * $v0</code>, 즉 <code style="font-family: RobotoMono,monospace;">1 * 1</code> 값을 저장하고, <code style="font-family: RobotoMono,monospace;">$ra</code> 위치로 넘어간다. <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 여전히 <code style="font-family: RobotoMono,monospace;">L1 $ra</code> 위치</strong>다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+--------+------------+--------+--------+</span></span>
<span class="line"><span>| $a = 3 | caller $ra | $a = 2 | L1 $ra |</span></span>
<span class="line"><span>+--------+------------+--------+--------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">앞서 stack pointer의 위치를 8 움직였기 때문에 현재 스택의 모습은 위와 같다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">addi</span><span style="color:#24292E"> $sp, $sp, </span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 8 이동</span></span>
<span class="line"><span style="color:#005CC5">mul</span><span style="color:#24292E"> $v0, $a0, $v0 </span><span style="color:#6A737D"># $v0 = $a0 * $v0</span></span>
<span class="line"><span style="color:#005CC5">jr</span><span style="color:#24292E"> $ra</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이 과정을 반복한다. <code style="font-family: RobotoMono,monospace;">$a0</code>와 <code style="font-family: RobotoMono,monospace;">$ra</code>를 복원한다. 이제 <strong><code style="font-family: RobotoMono,monospace;">$a0</code>가 2</strong>이고 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 <code style="font-family: RobotoMono,monospace;">L1 $ra</code> 위치</strong>다. 그리고 다시 stack pointer의 위치를 8 움직인다. 이어서 <code style="font-family: RobotoMono,monospace;">$v0</code>에 <code style="font-family: RobotoMono,monospace;">$a0 * $v0</code>, 즉 <code style="font-family: RobotoMono,monospace;">2 * 1</code> 값을 저장하고, <code style="font-family: RobotoMono,monospace;">$ra</code> 위치로 넘어간다. <strong><code style="font-family: RobotoMono,monospace;">$ra</code> 는 <code style="font-family: RobotoMono,monospace;">L1 $ra</code> 위치</strong>다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+--------+------------+</span></span>
<span class="line"><span>| $a = 3 | caller $ra |</span></span>
<span class="line"><span>+--------+------------+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">stack pointer가 8만큼 이동한 현재 스택의 모습은 위와 같다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $a0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">lw</span><span style="color:#24292E"> $ra, </span><span style="color:#005CC5">4</span><span style="color:#24292E">($sp)</span></span>
<span class="line"><span style="color:#005CC5">addi</span><span style="color:#24292E"> $sp, $sp, </span><span style="color:#005CC5">8</span><span style="color:#6A737D"> # stack pointer 위치 8 이동</span></span>
<span class="line"><span style="color:#005CC5">mul</span><span style="color:#24292E"> $v0, $a0, $v0 </span><span style="color:#6A737D"># $v0 = $a0 * $v0</span></span>
<span class="line"><span style="color:#005CC5">jr</span><span style="color:#24292E"> $ra</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이제 마지막 단계다. 스택에서 <code style="font-family: RobotoMono,monospace;">$a0</code>와 <code style="font-family: RobotoMono,monospace;">$ra</code>를 가져온다. 이제 <strong><code style="font-family: RobotoMono,monospace;">$a0</code>가 3</strong>이고 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 <code style="font-family: RobotoMono,monospace;">caller $ra</code> 위치</strong>다. 다시 stack pointer의 위치를 8 움직이면 이제 stack pointer를 초기 값으로 돌려놓게 된다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;"><code style="font-family: RobotoMono,monospace;">$v0</code>에 <code style="font-family: RobotoMono,monospace;">$a0 * $v0</code>, 즉 <code style="font-family: RobotoMono,monospace;">3 * 2</code> 값을 저장하고, <code style="font-family: RobotoMono,monospace;">$ra</code> 위치로 넘어간다. 이때 <strong><code style="font-family: RobotoMono,monospace;">$ra</code>는 caller 위치</strong>이며, caller에서 <code style="font-family: RobotoMono,monospace;">$v0</code>에 접근하면 6을 얻을 수 있을 것이다. <code style="font-family: RobotoMono,monospace;">factorial</code>이 제대로 동작했다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">마치 인간 컴퓨터가 된 기분이다.</p><h3 id="memory-layout"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">Memory Layout</h3><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+---------------+ High address</span></span>
<span class="line"><span>|     Stack     |</span></span>
<span class="line"><span>+-------+-------+</span></span>
<span class="line"><span>|       |       |</span></span>
<span class="line"><span>|       v       |</span></span>
<span class="line"><span>|               |</span></span>
<span class="line"><span>|       ^       |</span></span>
<span class="line"><span>|       |       |</span></span>
<span class="line"><span>+-------+-------+</span></span>
<span class="line"><span>|     Heap      |</span></span>
<span class="line"><span>+---------------+</span></span>
<span class="line"><span>| Static (Data) |</span></span>
<span class="line"><span>+---------------+</span></span>
<span class="line"><span>|  Text (Code)  |</span></span>
<span class="line"><span>+---------------+ Low address</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">그림의 Code Segment는 Text라고 불리며, 실제 프로그램 코드가 저장된다. Data Segment는 Static Data라고 불리며, 상수 배열이나 문자열, static 변수가 저장된다. Heap에는 동적할당된 배열 요소나 객체가 저장되며, Stack에는 함수나 메소드, 지역변수 등이 저장된다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">앞서 스택에 값을 저장하고 불러오는 과정이 위와 같은 메모리 구조를 바탕으로 이뤄진다. 스택은 높은 곳에서 낮은 곳으로 자라기 때문에 <code style="font-family: RobotoMono,monospace;">addi $sp, $sp, -8</code>처럼 stack poniter를 음의 방향으로 움직여준 것이다. 값을 저장할 때도 <code style="font-family: RobotoMono,monospace;">sw $ra 4($sp)</code>다음 <code style="font-family: RobotoMono,monospace;">sw $a0, 0($sp)</code>를 했다. 스택과 달리 heap은 낮은 곳에서 높은 곳으로 자란다.</p><h3 id="mips-instruction-formats"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">MIPS Instruction Formats</h3><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">MIPS에서 어셈블러가 한 줄씩 instruction을 읽고 이를 기계어로 변환할 때, 기계어를 표현하는 세가지 형식 R(Register), I(Immediate), J(Jump)가 있다.</p><h4 id="r-format"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">R-format</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">R-format은 레지스터를 이용해 연산하는 instruction을 담는 형식이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+----+----+----+----+-------+-------+</span></span>
<span class="line"><span>| op | rs | rt | rd | shamt | funct |</span></span>
<span class="line"><span>+----+----+----+----+-------+-------+</span></span></code></pre><ul style="margin: 0; padding: 0; margin-bottom: 1rem; margin-left: 2rem;"><li style="line-height: 1.7rem;">op(6bits): 포맷과 동작을 구분하는 필드.</li><li style="line-height: 1.7rem;">rs(5bits): first source register number</li><li style="line-height: 1.7rem;">rt(5bits): second source register number</li><li style="line-height: 1.7rem;">rd(5bits): destination register number</li><li style="line-height: 1.7rem;">shamt(5bits): shift 연산에 사용되는 필드.</li><li style="line-height: 1.7rem;">funct(6bits): op보다 구체적인 정보를 담은 필드.</li></ul><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">만약 다음과 같은 MIPS 코드가 있다고 가정해보자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#005CC5">add</span><span style="color:#24292E"> $t0, $s1, $s2</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이를 R-format으로 표현하면 이렇게 될 것이다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+---------+-----+-----+-----+---+-----+</span></span>
<span class="line"><span>| special | $s1 | $s2 | $t0 | 0 | add |</span></span>
<span class="line"><span>+---------+-----+-----+-----+---+-----+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">register table에 따라 이것을 10진수로 변환하면:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+---+----+----+---+---+----+</span></span>
<span class="line"><span>| 0 | 17 | 18 | 8 | 0 | 32 |</span></span>
<span class="line"><span>+---+----+----+---+---+----+</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">각 레지스터의 값과 <code style="font-family: RobotoMono,monospace;">add</code> instruction의 opcode, funct 값, rs, rt, rd 위치 등은 모두 사전에 정의된 것으로, <a href="https://inst.eecs.berkeley.edu/~cs61c/resources/MIPS_Green_Sheet.pdf"style="text-decoration: none; cursor: pointer; color: #005ccc;">MIPS Green Sheet</a>를 참고하면 된다. 이어서 각 필드를 2진수로 바꾸면 실제 메모리에 들어가는 값이 된다:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>00000010001100100100000000100000</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">컴퓨터는 이렇게 변환된 바이너리 숫자를 보고 명령을 수행한다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">이렇게 보면 바로 funct를 확인하면 되니까 op가 필요하지 않을 것 같다. 사실 32bit 시스템에서 쉽게 instruction을 읽기 위해 32비트를 맞추는 것이 복잡도를 줄이는 데 도움이 되기 때문에 메모리 손해를 감안한 것이다.</p><h4 id="i-format"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">I-format</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">I-format은 상수 연산과 메모리 연산을 위해 사용된다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+----+----+----+-----+</span></span>
<span class="line"><span>| op | rs | rt | IMM |</span></span>
<span class="line"><span>+----+----+----+-----+</span></span></code></pre><ul style="margin: 0; padding: 0; margin-bottom: 1rem; margin-left: 2rem;"><li style="line-height: 1.7rem;">op(6bits): 포맷과 동작을 구분하는 필드.</li><li style="line-height: 1.7rem;">rs(5bits), rt(5bits): source or destination register number</li><li style="line-height: 1.7rem;">IMM(16bits): constant나 address가 담긴다. constant의 경우 -215부터 215 - 1까지의 상수를 저장할 수 있다. address의 경우 rs의 base address에 offset으로 기능하거나 점프해야 하는 instruction까지의 거리를 저장한다.</li></ul><h4 id="j-format"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.2rem;">J-format</h4><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">J-format은 다른 위치로 점프할 때 사용되는 포맷이다.</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-text"style="font-family: RobotoMono,monospace;"><span class="line"><span>+----+----------------+</span></span>
<span class="line"><span>| op | pseudo-address |</span></span>
<span class="line"><span>+----+----------------+</span></span></code></pre><ul style="margin: 0; padding: 0; margin-bottom: 1rem; margin-left: 2rem;"><li style="line-height: 1.7rem;">op(6bits): 포맷과 동작을 구분하는 필드.</li><li style="line-height: 1.7rem;">pseudo-address(26bits): 점프할 instruction의 변환된 주소가 담기는 필드.</li></ul><h3 id="mips-addressing-for-32-bit-immediates-and-addresses"tabindex="-1"style="margin: 0; padding: 0; margin-bottom: 1rem; font-weight: 700; font-size: 1.3rem;">MIPS Addressing for 32-bit Immediates and Addresses</h3><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">MIPS instruction format 중 I-format은 <code style="font-family: RobotoMono,monospace;">bne $t0, $s5, Exit</code>와 같은 구문을 표현할 때도 사용된다. 그런데 I-foramt의 마지막 필드인 constant or address는 16bits밖에 되지 않아 <code style="font-family: RobotoMono,monospace;">Exit</code>에서 수행될 동작 전체를 담는 것은 불가능하다. 따라서 이곳에는 <code style="font-family: RobotoMono,monospace;">Exit</code>가 몇 줄 떨어져 있는지를 저장한다. 앞서 활용한 Loop 코드를 다시 보자:</p><pre class="shiki github-light"style="display: block; overflow-x: auto; padding-left: 1rem; margin-bottom: 1rem; line-height: 1.3rem; background-color: #fff; color: #24292e;"tabindex="0"><code class="language-mips"style="font-family: RobotoMono,monospace;"><span class="line"><span style="color:#6F42C1">Loop</span><span style="color:#24292E">:                 </span><span style="color:#6A737D"># address: 8000</span></span>
<span class="line"><span style="color:#005CC5">  sll</span><span style="color:#24292E"> $t1, $s3, </span><span style="color:#005CC5">2</span><span style="color:#6A737D">     # R-format: | 0  | 0  | 19 | 9 | 4 | 0  |</span></span>
<span class="line"><span style="color:#005CC5">  add</span><span style="color:#24292E"> $t1, $t1, $s6   </span><span style="color:#6A737D"># R-format: | 0  | 9  | 22 | 9 | 0 | 32 |</span></span>
<span class="line"><span style="color:#005CC5">  lw</span><span style="color:#24292E"> $t0, </span><span style="color:#005CC5">0</span><span style="color:#24292E">($t1)      </span><span style="color:#6A737D"># I-format: | 35 | 9  | 8  |     0      |</span></span>
<span class="line"><span style="color:#005CC5">  bne</span><span style="color:#24292E"> $t0, $s5, Exit  </span><span style="color:#6A737D"># I-format: | 5  | 8  | 21 |     2      |</span></span>
<span class="line"><span style="color:#005CC5">  addi</span><span style="color:#24292E"> $s3, $s3, </span><span style="color:#005CC5">1</span><span style="color:#6A737D">    # I-format: | 8  | 19 | 19 |     1      |</span></span>
<span class="line"><span style="color:#005CC5">  j</span><span style="color:#24292E"> Loop              </span><span style="color:#6A737D"># J-format: | 2  |         2000         |</span></span>
<span class="line"><span style="color:#6F42C1">Exit</span><span style="color:#24292E">:</span></span>
<span class="line"><span style="color:#24292E">  ...</span></span></code></pre><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">여기서 <code style="font-family: RobotoMono,monospace;">bne $t0, $s5, Exit</code> 라인의 I-format을 보자. constant or address에 2가 있는 것을 볼 수 있는데, 이는 Exit가 해당 라인에서 2칸 떨어져 있다는 의미다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">J-format의 경우도 pseudo-address 필드가 26bits밖에 되지 않아 모든 instruction을 담을 수 없다. J-format의 pseudo-address 필드에는 점프해야 하는 위치의 주소를 2만큼 right shift한 값이 들어간다. 위 코드에서 <code style="font-family: RobotoMono,monospace;">j Loop</code> 라인의 J-format을 보자. pseudo-address 필드에 2000이 있는데, 점프해야 하는 <code style="font-family: RobotoMono,monospace;">Loop</code>의 address는 8000이다. 이때 2000에 2만큼 left shift(<code style="font-family: RobotoMono,monospace;">2000 &lt;&lt; 2</code>)하면 8000을 얻을 수 있다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">위와 같은 매커니즘을 수행하기 위해 어셈블러는 구체적인 instruction을 기계어로 변환하기 전 코드 전체를 스캔해 라벨의 위치를 파악한다. 이후 순서대로 instruction을 읽으며 기계어로 변환하다가 점프해야 하는 부분이 나오면 그 부분의 instruction을 기계어로 변환한다. 이런 식으로 모든 instruction을 순서에 맞춰 기계어로 변환하면 비로소 컴퓨터가 이해할 수 있는 결과물이 나온다.</p><p style="font-size: 1rem; line-height: 1.7rem; margin-bottom: 1rem;">여기까지가 MIPS instruction에 대한 기본적인 내용이다. 더 들어가면 프로세서, 메모리의 동작이나 디지털 회로를 이용한 바이너리 연산에 대한 내용도 다룰 수 있을 것 같은데, 일단은 컴퓨터 아키텍처의 개요와 컴퓨터가 코드를 해석하고 실행하는 과정만을 살펴봤다.</p></section><section id="article-navigation"style="margin-top: 50px; overflow: hidden;"><div class="article-navigation-item article-navigation-next"style="margin-bottom: 1rem; text-align: left; float: left; margin-right: 5px;"><a href="26.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-next symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: left; float: left; margin-right: 5px;">←</div><div class="article-navigation-content article-navigation-next"style="text-align: left; float: left; margin-right: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">🎅 요정을 착취하는 방치형 게임 개발한 이야기</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">ES6 OOP와 타입스크립트, 그리고 제이쿼리(?)</p></div></a></div><div class="article-navigation-item article-navigation-prev"style="margin-bottom: 1rem; text-align: right; float: right; margin-left: 5px;"><a href="24.html"style="color: #000; text-decoration: none; cursor: pointer;"><div class="article-navigation-arrow article-navigation-prev symbol"style="font-family: Pretendard,sans-serif; font-size: .9rem; text-align: right; float: right; margin-left: 5px;">→</div><div class="article-navigation-content article-navigation-prev"style="text-align: right; float: right; margin-left: 5px;"><p class="article-navigation-title"style="font-weight: 700; font-size: 1rem; margin: 0;">🔐 HTTPS는 어떻게 다를까?</p><p class="article-navigation-subtitle"style="font-weight: 400; font-size: .8rem; margin: 0;">진짜 데이터를 뜯어보았다</p></div></a></div></section><section id="article-comments"><script async src="https://utteranc.es/client.js"repo="parksb/parksb.github.io-comments"issue-term="pathname"theme="github-light"crossorigin="anonymous"></script></section><div class="back-to-article-list"style="font-size: 1rem; margin-bottom: 1rem;"><a href="../articles.html"style="color: #000; text-decoration: none; cursor: pointer;"><span class="symbol"style="font-family: Pretendard,sans-serif;">←</span> Articles</a></div></article></main><footer style="font-size: .8rem; color: #767676;">이 글은 CC BY-NC 4.0 라이선스에 따라 이용할 수 있습니다.</footer><script async src="https://www.googletagmanager.com/gtag/js?id=G-LKTJ5YFJR2"></script><script>window.dataLayer = window.dataLayer || [];
    function gtag(){dataLayer.push(arguments);}
    gtag('js', new Date());
    gtag('config', 'G-LKTJ5YFJR2');</script></body></html>